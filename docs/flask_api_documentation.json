{
  "blueprints": {
    "coach_g": {
      "name": "coach_g",
      "directory": "blueprints\\coach_g",
      "url_prefix": "/coach",
      "blueprint_variable": "coach_g_bp",
      "routes": [
        {
          "function_name": "coach_g",
          "endpoint": "/",
          "methods": [
            "GET"
          ],
          "docstring": "Render Coach G chat interface.",
          "parameters": [],
          "line_number": 38,
          "blueprint": "coach_g",
          "full_url": "/coach/"
        },
        {
          "function_name": "coach_g_chat",
          "endpoint": "/api/chat/",
          "methods": [
            "POST"
          ],
          "docstring": "Handle Coach G chat interactions.",
          "parameters": [],
          "line_number": 43,
          "blueprint": "coach_g",
          "full_url": "/coach/api/chat/"
        }
      ],
      "imports": [
        "logging",
        "os",
        "uuid",
        "flask.Blueprint",
        "flask.render_template",
        "flask.request",
        "flask.jsonify",
        "services.coach_g_service.CoachGService"
      ],
      "services_used": [
        "CoachGService",
        "coach_g_service"
      ]
    },
    "runner_vision": {
      "name": "runner_vision",
      "directory": "blueprints\\runner_vision",
      "url_prefix": "/vision",
      "blueprint_variable": "runner_vision_bp",
      "routes": [
        {
          "function_name": "runnervision",
          "endpoint": "/",
          "methods": [
            "GET"
          ],
          "docstring": "Display RunnerVision analysis results.",
          "parameters": [],
          "line_number": 37,
          "blueprint": "runner_vision",
          "full_url": "/vision/"
        },
        {
          "function_name": "serve_report",
          "endpoint": "/reports/<path:filename>",
          "methods": [
            "GET"
          ],
          "docstring": "Serve RunnerVision report files.",
          "parameters": [
            "filename"
          ],
          "line_number": 47,
          "blueprint": "runner_vision",
          "full_url": "/vision/reports/<path:filename>"
        },
        {
          "function_name": "serve_video",
          "endpoint": "/videos/<path:filename>",
          "methods": [
            "GET"
          ],
          "docstring": "Serve RunnerVision video files.",
          "parameters": [
            "filename"
          ],
          "line_number": 52,
          "blueprint": "runner_vision",
          "full_url": "/vision/videos/<path:filename>"
        },
        {
          "function_name": "upload_files",
          "endpoint": "/upload",
          "methods": [
            "POST"
          ],
          "docstring": "Handle video file uploads.",
          "parameters": [],
          "line_number": 57,
          "blueprint": "runner_vision",
          "full_url": "/vision/upload"
        },
        {
          "function_name": "run_analysis",
          "endpoint": "/run_biomechanic_analysis",
          "methods": [
            "POST"
          ],
          "docstring": "Execute biomechanics analysis.",
          "parameters": [],
          "line_number": 71,
          "blueprint": "runner_vision",
          "full_url": "/vision/run_biomechanic_analysis"
        }
      ],
      "imports": [
        "logging",
        "os",
        "flask.Blueprint",
        "flask.render_template",
        "flask.request",
        "flask.jsonify",
        "services.runnervision_service.RunnerVisionService"
      ],
      "services_used": [
        "RunnerVisionService",
        "runnervision_service"
      ]
    },
    "running_hub": {
      "name": "running_hub",
      "directory": "blueprints\\running_hub",
      "url_prefix": "/hub",
      "blueprint_variable": "running_hub_bp",
      "routes": [
        {
          "function_name": "home",
          "endpoint": "/",
          "methods": [
            "GET"
          ],
          "docstring": "RunningHub home page with latest activity.",
          "parameters": [],
          "line_number": 61,
          "blueprint": "running_hub",
          "full_url": "/hub/"
        },
        {
          "function_name": "activity",
          "endpoint": "/activity/",
          "methods": [
            "GET"
          ],
          "docstring": "Display detailed activity information for specific activity ID.",
          "parameters": [],
          "line_number": 72,
          "blueprint": "running_hub",
          "full_url": "/hub/activity/"
        },
        {
          "function_name": "query",
          "endpoint": "/query/",
          "methods": [
            "GET",
            "POST"
          ],
          "docstring": "Handle database queries.",
          "parameters": [],
          "line_number": 93,
          "blueprint": "running_hub",
          "full_url": "/hub/query/"
        },
        {
          "function_name": "ai_query",
          "endpoint": "/ai_query",
          "methods": [
            "POST"
          ],
          "docstring": "AI-powered natural language query interface.",
          "parameters": [],
          "line_number": 111,
          "blueprint": "running_hub",
          "full_url": "/hub/ai_query"
        },
        {
          "function_name": "statistics",
          "endpoint": "/statistics/",
          "methods": [
            "GET"
          ],
          "docstring": "Display time period aggregated running statistics.",
          "parameters": [],
          "line_number": 141,
          "blueprint": "running_hub",
          "full_url": "/hub/statistics/"
        },
        {
          "function_name": "trophy_room",
          "endpoint": "/trophy_room/",
          "methods": [
            "GET"
          ],
          "docstring": "Display personal records and achievements.",
          "parameters": [],
          "line_number": 157,
          "blueprint": "running_hub",
          "full_url": "/hub/trophy_room/"
        },
        {
          "function_name": "motivation",
          "endpoint": "/motivation",
          "methods": [
            "GET"
          ],
          "docstring": "Motivation Page, including upcoming races and inspriational LLM quote generator",
          "parameters": [],
          "line_number": 172,
          "blueprint": "running_hub",
          "full_url": "/hub/motivation"
        },
        {
          "function_name": "daily_motivation",
          "endpoint": "/api/daily_motivation",
          "methods": [
            "POST"
          ],
          "docstring": "API endpoint to generate a daily motivational message based on selected personality.",
          "parameters": [],
          "line_number": 200,
          "blueprint": "running_hub",
          "full_url": "/hub/api/daily_motivation"
        },
        {
          "function_name": "skill_tree",
          "endpoint": "/skill_tree/",
          "methods": [
            "GET"
          ],
          "docstring": "Progressive skill tree for running achievement and side-quests.",
          "parameters": [],
          "line_number": 223,
          "blueprint": "running_hub",
          "full_url": "/hub/skill_tree/"
        }
      ],
      "imports": [
        "logging",
        "os",
        "uuid",
        "json",
        "flask.Blueprint",
        "flask.render_template",
        "flask.request",
        "flask.redirect",
        "flask.abort",
        "flask.jsonify",
        "flask.url_for",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.NotFound",
        "services.activity_service.ActivityService",
        "services.query_service.QueryService",
        "services.statistics_service.StatisticsService",
        "services.trophy_service.TrophyService",
        "services.motivation_service.MotivationService",
        "utils.exception_utils",
        "utils.db.db_utils",
        "utils.lm_utils",
        "config.Config"
      ],
      "services_used": [
        "StatisticsService",
        "TrophyService",
        "QueryService",
        "ActivityService",
        "motivation_service",
        "activity_service",
        "MotivationService",
        "trophy_service",
        "statistics_service",
        "query_service"
      ]
    },
    "run_strong": {
      "name": "run_strong",
      "directory": "blueprints\\run_strong",
      "url_prefix": "/strong",
      "blueprint_variable": "run_strong_bp",
      "routes": [
        {
          "function_name": "runstrong",
          "endpoint": "/",
          "methods": [
            "GET"
          ],
          "docstring": "Display RunStrong home page.",
          "parameters": [],
          "line_number": 51,
          "blueprint": "run_strong",
          "full_url": "/strong/"
        },
        {
          "function_name": "get_exercises",
          "endpoint": "/api/exercises",
          "methods": [
            "GET"
          ],
          "docstring": "API: Get all exercises for the planner.",
          "parameters": [],
          "line_number": 56,
          "blueprint": "run_strong",
          "full_url": "/strong/api/exercises"
        },
        {
          "function_name": "exercise_library",
          "endpoint": "/exercise_library",
          "methods": [
            "GET"
          ],
          "docstring": "Display the exercise library page.",
          "parameters": [],
          "line_number": 66,
          "blueprint": "run_strong",
          "full_url": "/strong/exercise_library"
        },
        {
          "function_name": "journal",
          "endpoint": "/journal",
          "methods": [
            "GET"
          ],
          "docstring": "Display the workout journal page and the form for new entries.",
          "parameters": [],
          "line_number": 76,
          "blueprint": "run_strong",
          "full_url": "/strong/journal"
        },
        {
          "function_name": "log_workout_entry",
          "endpoint": "/api/journal/log",
          "methods": [
            "POST"
          ],
          "docstring": "API endpoint to log a new workout session.",
          "parameters": [],
          "line_number": 89,
          "blueprint": "run_strong",
          "full_url": "/strong/api/journal/log"
        },
        {
          "function_name": "fatigue_dashboard",
          "endpoint": "/fatigue_dashboard",
          "methods": [
            "GET"
          ],
          "docstring": "Display the enhanced fatigue dashboard page.",
          "parameters": [],
          "line_number": 106,
          "blueprint": "run_strong",
          "full_url": "/strong/fatigue_dashboard"
        },
        {
          "function_name": "goals",
          "endpoint": "/goals",
          "methods": [
            "GET"
          ],
          "docstring": "Display the goals dashboard page.",
          "parameters": [],
          "line_number": 117,
          "blueprint": "run_strong",
          "full_url": "/strong/goals"
        },
        {
          "function_name": "max_weights",
          "endpoint": "/max-weights",
          "methods": [
            "GET"
          ],
          "docstring": "Display exercise max weights page.",
          "parameters": [],
          "line_number": 127,
          "blueprint": "run_strong",
          "full_url": "/strong/max-weights"
        },
        {
          "function_name": "get_exercise_max",
          "endpoint": "/api/exercise-max/<int:exercise_id>",
          "methods": [
            "GET"
          ],
          "docstring": "API: Get maximum weight for a specific exercise.",
          "parameters": [
            "exercise_id"
          ],
          "line_number": 137,
          "blueprint": "run_strong",
          "full_url": "/strong/api/exercise-max/<int:exercise_id>"
        }
      ],
      "imports": [
        "logging",
        "os",
        "flask.Blueprint",
        "flask.render_template",
        "flask.request",
        "flask.jsonify",
        "werkzeug.exceptions.BadRequest",
        "services.runstrong_service.RunStrongService"
      ],
      "services_used": [
        "runstrong_service",
        "RunStrongService"
      ]
    }
  },
  "routes": [
    {
      "function_name": "coach_g",
      "endpoint": "/",
      "methods": [
        "GET"
      ],
      "docstring": "Render Coach G chat interface.",
      "parameters": [],
      "line_number": 38,
      "blueprint": "coach_g",
      "full_url": "/coach/"
    },
    {
      "function_name": "coach_g_chat",
      "endpoint": "/api/chat/",
      "methods": [
        "POST"
      ],
      "docstring": "Handle Coach G chat interactions.",
      "parameters": [],
      "line_number": 43,
      "blueprint": "coach_g",
      "full_url": "/coach/api/chat/"
    },
    {
      "function_name": "runnervision",
      "endpoint": "/",
      "methods": [
        "GET"
      ],
      "docstring": "Display RunnerVision analysis results.",
      "parameters": [],
      "line_number": 37,
      "blueprint": "runner_vision",
      "full_url": "/vision/"
    },
    {
      "function_name": "serve_report",
      "endpoint": "/reports/<path:filename>",
      "methods": [
        "GET"
      ],
      "docstring": "Serve RunnerVision report files.",
      "parameters": [
        "filename"
      ],
      "line_number": 47,
      "blueprint": "runner_vision",
      "full_url": "/vision/reports/<path:filename>"
    },
    {
      "function_name": "serve_video",
      "endpoint": "/videos/<path:filename>",
      "methods": [
        "GET"
      ],
      "docstring": "Serve RunnerVision video files.",
      "parameters": [
        "filename"
      ],
      "line_number": 52,
      "blueprint": "runner_vision",
      "full_url": "/vision/videos/<path:filename>"
    },
    {
      "function_name": "upload_files",
      "endpoint": "/upload",
      "methods": [
        "POST"
      ],
      "docstring": "Handle video file uploads.",
      "parameters": [],
      "line_number": 57,
      "blueprint": "runner_vision",
      "full_url": "/vision/upload"
    },
    {
      "function_name": "run_analysis",
      "endpoint": "/run_biomechanic_analysis",
      "methods": [
        "POST"
      ],
      "docstring": "Execute biomechanics analysis.",
      "parameters": [],
      "line_number": 71,
      "blueprint": "runner_vision",
      "full_url": "/vision/run_biomechanic_analysis"
    },
    {
      "function_name": "home",
      "endpoint": "/",
      "methods": [
        "GET"
      ],
      "docstring": "RunningHub home page with latest activity.",
      "parameters": [],
      "line_number": 61,
      "blueprint": "running_hub",
      "full_url": "/hub/"
    },
    {
      "function_name": "activity",
      "endpoint": "/activity/",
      "methods": [
        "GET"
      ],
      "docstring": "Display detailed activity information for specific activity ID.",
      "parameters": [],
      "line_number": 72,
      "blueprint": "running_hub",
      "full_url": "/hub/activity/"
    },
    {
      "function_name": "query",
      "endpoint": "/query/",
      "methods": [
        "GET",
        "POST"
      ],
      "docstring": "Handle database queries.",
      "parameters": [],
      "line_number": 93,
      "blueprint": "running_hub",
      "full_url": "/hub/query/"
    },
    {
      "function_name": "ai_query",
      "endpoint": "/ai_query",
      "methods": [
        "POST"
      ],
      "docstring": "AI-powered natural language query interface.",
      "parameters": [],
      "line_number": 111,
      "blueprint": "running_hub",
      "full_url": "/hub/ai_query"
    },
    {
      "function_name": "statistics",
      "endpoint": "/statistics/",
      "methods": [
        "GET"
      ],
      "docstring": "Display time period aggregated running statistics.",
      "parameters": [],
      "line_number": 141,
      "blueprint": "running_hub",
      "full_url": "/hub/statistics/"
    },
    {
      "function_name": "trophy_room",
      "endpoint": "/trophy_room/",
      "methods": [
        "GET"
      ],
      "docstring": "Display personal records and achievements.",
      "parameters": [],
      "line_number": 157,
      "blueprint": "running_hub",
      "full_url": "/hub/trophy_room/"
    },
    {
      "function_name": "motivation",
      "endpoint": "/motivation",
      "methods": [
        "GET"
      ],
      "docstring": "Motivation Page, including upcoming races and inspriational LLM quote generator",
      "parameters": [],
      "line_number": 172,
      "blueprint": "running_hub",
      "full_url": "/hub/motivation"
    },
    {
      "function_name": "daily_motivation",
      "endpoint": "/api/daily_motivation",
      "methods": [
        "POST"
      ],
      "docstring": "API endpoint to generate a daily motivational message based on selected personality.",
      "parameters": [],
      "line_number": 200,
      "blueprint": "running_hub",
      "full_url": "/hub/api/daily_motivation"
    },
    {
      "function_name": "skill_tree",
      "endpoint": "/skill_tree/",
      "methods": [
        "GET"
      ],
      "docstring": "Progressive skill tree for running achievement and side-quests.",
      "parameters": [],
      "line_number": 223,
      "blueprint": "running_hub",
      "full_url": "/hub/skill_tree/"
    },
    {
      "function_name": "runstrong",
      "endpoint": "/",
      "methods": [
        "GET"
      ],
      "docstring": "Display RunStrong home page.",
      "parameters": [],
      "line_number": 51,
      "blueprint": "run_strong",
      "full_url": "/strong/"
    },
    {
      "function_name": "get_exercises",
      "endpoint": "/api/exercises",
      "methods": [
        "GET"
      ],
      "docstring": "API: Get all exercises for the planner.",
      "parameters": [],
      "line_number": 56,
      "blueprint": "run_strong",
      "full_url": "/strong/api/exercises"
    },
    {
      "function_name": "exercise_library",
      "endpoint": "/exercise_library",
      "methods": [
        "GET"
      ],
      "docstring": "Display the exercise library page.",
      "parameters": [],
      "line_number": 66,
      "blueprint": "run_strong",
      "full_url": "/strong/exercise_library"
    },
    {
      "function_name": "journal",
      "endpoint": "/journal",
      "methods": [
        "GET"
      ],
      "docstring": "Display the workout journal page and the form for new entries.",
      "parameters": [],
      "line_number": 76,
      "blueprint": "run_strong",
      "full_url": "/strong/journal"
    },
    {
      "function_name": "log_workout_entry",
      "endpoint": "/api/journal/log",
      "methods": [
        "POST"
      ],
      "docstring": "API endpoint to log a new workout session.",
      "parameters": [],
      "line_number": 89,
      "blueprint": "run_strong",
      "full_url": "/strong/api/journal/log"
    },
    {
      "function_name": "fatigue_dashboard",
      "endpoint": "/fatigue_dashboard",
      "methods": [
        "GET"
      ],
      "docstring": "Display the enhanced fatigue dashboard page.",
      "parameters": [],
      "line_number": 106,
      "blueprint": "run_strong",
      "full_url": "/strong/fatigue_dashboard"
    },
    {
      "function_name": "goals",
      "endpoint": "/goals",
      "methods": [
        "GET"
      ],
      "docstring": "Display the goals dashboard page.",
      "parameters": [],
      "line_number": 117,
      "blueprint": "run_strong",
      "full_url": "/strong/goals"
    },
    {
      "function_name": "max_weights",
      "endpoint": "/max-weights",
      "methods": [
        "GET"
      ],
      "docstring": "Display exercise max weights page.",
      "parameters": [],
      "line_number": 127,
      "blueprint": "run_strong",
      "full_url": "/strong/max-weights"
    },
    {
      "function_name": "get_exercise_max",
      "endpoint": "/api/exercise-max/<int:exercise_id>",
      "methods": [
        "GET"
      ],
      "docstring": "API: Get maximum weight for a specific exercise.",
      "parameters": [
        "exercise_id"
      ],
      "line_number": 137,
      "blueprint": "run_strong",
      "full_url": "/strong/api/exercise-max/<int:exercise_id>"
    }
  ],
  "services": {
    "activity_service": {
      "file_path": "services\\activity_service.py",
      "classes": [
        {
          "name": "ActivityService",
          "docstring": "Service for handling activity-related operations.",
          "methods": [
            {
              "name": "get_latest_activity_id",
              "docstring": "Get the ID of the most recent run activity.",
              "parameters": [],
              "return_type": "Optional[int]",
              "line_number": 20,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_formatted_activity_page_details",
              "docstring": "Retrieves all activity information with formatted data.",
              "parameters": [
                {
                  "name": "activity_id",
                  "type": "int"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Optional[Dict[(str, Any)]]",
              "line_number": 29,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_format_activity_data",
              "docstring": "Format activity data for display, including unit conversion for miles and kilometers.",
              "parameters": [
                {
                  "name": "activity",
                  "type": "Dict[(str, Any)]"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 40,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 17,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "sqlite3",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "services.base_service.BaseService",
        "utils.format_utils",
        "utils.exception_utils",
        "utils.db.db_utils",
        "utils.db.running_hub_db_utils"
      ]
    },
    "base_service": {
      "file_path": "services\\base_service.py",
      "classes": [
        {
          "name": "BaseService",
          "docstring": "Abstract base class for all services.",
          "methods": [
            {
              "name": "__init__",
              "docstring": null,
              "parameters": [
                {
                  "name": "db_path",
                  "type": "str"
                }
              ],
              "return_type": null,
              "line_number": 31,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_connection",
              "docstring": "Get database connection with error handling.",
              "parameters": [],
              "return_type": "sqlite3.Connection",
              "line_number": 35,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 28,
          "bases": [
            "ABC"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging",
        "sqlite3",
        "abc.ABC",
        "abc.abstractmethod",
        "datetime.datetime",
        "datetime.timedelta",
        "uuid",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "dateutil.relativedelta.relativedelta",
        "flask.send_from_directory",
        "flask.abort",
        "werkzeug.utils.secure_filename",
        "os",
        "utils.format_utils",
        "utils.exception_utils",
        "config.Config",
        "utils.db.db_utils"
      ]
    },
    "coach_g_service": {
      "file_path": "services\\coach_g_service.py",
      "classes": [
        {
          "name": "CoachGService",
          "docstring": "Service for handling Coach G interactions.",
          "methods": [
            {
              "name": "__init__",
              "docstring": null,
              "parameters": [
                {
                  "name": "config"
                }
              ],
              "return_type": null,
              "line_number": 21,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_initialize_language_model",
              "docstring": "Initialize the language model.",
              "parameters": [],
              "return_type": null,
              "line_number": 28,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "handle_quick_query",
              "docstring": "Handles the user's quick query by routing to the appropriate function.",
              "parameters": [
                {
                  "name": "session_id",
                  "type": "str"
                },
                {
                  "name": "user_query",
                  "type": "str"
                },
                {
                  "name": "personality",
                  "type": "str"
                },
                {
                  "name": "topic",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "line_number": 43,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "handle_user_query",
              "docstring": "Handles the user's query by routing to the appropriate function based on keywords.",
              "parameters": [
                {
                  "name": "session_id",
                  "type": "str"
                },
                {
                  "name": "user_query",
                  "type": "str"
                },
                {
                  "name": "personality",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "line_number": 86,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_text_summary_for_history",
              "docstring": "Creates a simple, text-only summary for the LLM's context history.",
              "parameters": [
                {
                  "name": "metrics",
                  "type": "Dict"
                }
              ],
              "return_type": "str",
              "line_number": 137,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_daily_training_summary",
              "docstring": "Fetches, formats, and converts the latest daily training metrics to HTML.",
              "parameters": [
                {
                  "name": "conn",
                  "type": "sqlite3.Connection"
                }
              ],
              "return_type": "str",
              "line_number": 190,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_strength_training_summary",
              "docstring": "Fetches, formats, and converts the latest strength training metrics to HTML.",
              "parameters": [],
              "return_type": "tuple",
              "line_number": 215,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_summary_for_strength_history",
              "docstring": "Creates a simple, text-only summary for the LLM's context history on strength training fatigue.",
              "parameters": [
                {
                  "name": "strength_metrics",
                  "type": "dict"
                }
              ],
              "return_type": "tuple",
              "line_number": 239,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_strength_workout_recommendation",
              "docstring": "Generates a workout recommendation by creating a prompt for an LLM.",
              "parameters": [],
              "return_type": "tuple",
              "line_number": 279,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_prompt_for_recommendation",
              "docstring": "Creates a detailed, structured prompt for the LLM to generate a workout.",
              "parameters": [
                {
                  "name": "fatigue_data",
                  "type": "dict"
                },
                {
                  "name": "exercise_list",
                  "type": "list"
                }
              ],
              "return_type": "str",
              "line_number": 311,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_sanitize_user_input",
              "docstring": "Basic sanitization of user input.",
              "parameters": [
                {
                  "name": "user_query",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "line_number": 342,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_message",
              "docstring": "Save a message to the conversation history.",
              "parameters": [
                {
                  "name": "session_id",
                  "type": "str"
                },
                {
                  "name": "role",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": null,
              "line_number": 346,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_recent_messages",
              "docstring": "Retrieve recent messages for context.",
              "parameters": [
                {
                  "name": "session_id",
                  "type": "str"
                },
                {
                  "name": "max_tokens",
                  "type": "int"
                }
              ],
              "return_type": "List[Dict]",
              "line_number": 355,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_weekly_running_summary",
              "docstring": "Fetches and formats a summary of the last 7 days of running.\nReturns a text summary for history and a Markdown summary for the user.",
              "parameters": [],
              "return_type": "tuple[(str, str)]",
              "line_number": 364,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_training_trend_summary",
              "docstring": "Fetches and formats a summary of the last 28-day training trend.\nReturns a text summary for history and a Markdown summary for the user.",
              "parameters": [],
              "return_type": "tuple[(str, str)]",
              "line_number": 432,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_daily_motivational_message",
              "docstring": null,
              "parameters": [
                {
                  "name": "session_id",
                  "type": "str"
                },
                {
                  "name": "personality",
                  "type": "str"
                },
                {
                  "name": "profile_data",
                  "type": "dict"
                }
              ],
              "return_type": "str",
              "line_number": 497,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 18,
          "bases": [
            "RunStrongService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging",
        "re",
        "typing.List",
        "typing.Dict",
        "sqlite3",
        "json",
        "markdown",
        "services.runstrong_service.RunStrongService",
        "services.base_service.BaseService",
        "utils.language_model_utils",
        "utils.exception_utils",
        "config.LanguageModelConfig",
        "utils.db.language_db_utils",
        "utils.db.runstrong_db_utils"
      ]
    },
    "motivation_service": {
      "file_path": "services\\motivation_service.py",
      "classes": [
        {
          "name": "MotivationService",
          "docstring": "Service for managing personal records and achievements.",
          "methods": [],
          "line_number": 17,
          "bases": [
            "CoachGService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "sqlite3",
        "datetime.datetime",
        "datetime.timedelta",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "services.base_service.BaseService",
        "services.coach_g_service.CoachGService",
        "utils.db.db_utils",
        "utils.db.language_db_utils"
      ]
    },
    "query_service": {
      "file_path": "services\\query_service.py",
      "classes": [
        {
          "name": "QueryService",
          "docstring": "Service for handling database queries.",
          "methods": [
            {
              "name": "execute_query",
              "docstring": "Execute a database query with parameters.",
              "parameters": [
                {
                  "name": "sql_query",
                  "type": "str"
                },
                {
                  "name": "param_input",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 19,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 16,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "json",
        "typing.Dict",
        "typing.Any",
        "services.base_service.BaseService",
        "utils.format_utils",
        "utils.exception_utils",
        "utils.db.db_utils"
      ]
    },
    "runnervision_service": {
      "file_path": "services\\runnervision_service.py",
      "classes": [
        {
          "name": "RunnerVisionService",
          "docstring": "Service for RunnerVision biomechanics analysis.",
          "methods": [
            {
              "name": "__init__",
              "docstring": null,
              "parameters": [
                {
                  "name": "config"
                }
              ],
              "return_type": null,
              "line_number": 26,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_latest_analysis",
              "docstring": "Get latest RunnerVision analysis results.",
              "parameters": [],
              "return_type": "Dict[(str, Any)]",
              "line_number": 31,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "serve_report",
              "docstring": "Serve report files safely.",
              "parameters": [
                {
                  "name": "filename",
                  "type": "str"
                }
              ],
              "return_type": null,
              "line_number": 51,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "serve_video",
              "docstring": "Serve video files safely.",
              "parameters": [
                {
                  "name": "filename",
                  "type": "str"
                }
              ],
              "return_type": null,
              "line_number": 65,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "handle_file_upload",
              "docstring": "Handle video file uploads.",
              "parameters": [
                {
                  "name": "files",
                  "type": "List"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 85,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "run_analysis",
              "docstring": "Execute biomechanics analysis.",
              "parameters": [],
              "return_type": "Dict[(str, Any)]",
              "line_number": 118,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_allowed_file",
              "docstring": "Check if file extension is allowed.",
              "parameters": [
                {
                  "name": "filename",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "line_number": 135,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 23,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "dateutil.relativedelta.relativedelta",
        "flask.send_from_directory",
        "flask.abort",
        "werkzeug.utils.secure_filename",
        "os",
        "services.base_service.BaseService",
        "utils.format_utils",
        "utils.exception_utils",
        "utils.RunnerVision.runnervision_utils",
        "utils.db.db_utils"
      ]
    },
    "runstrong_service": {
      "file_path": "services\\runstrong_service.py",
      "classes": [
        {
          "name": "RunStrongService",
          "docstring": "Service for RunStrong strength training operations.",
          "methods": [
            {
              "name": "get_exercises",
              "docstring": "Get all available exercises.",
              "parameters": [],
              "return_type": "List[Dict]",
              "line_number": 23,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_exercises_with_load",
              "docstring": "Get all available exercises with load values.",
              "parameters": [],
              "return_type": "List[Dict]",
              "line_number": 32,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_exercise_details",
              "docstring": "Get details for a specific exercise.",
              "parameters": [
                {
                  "name": "exercise_id",
                  "type": "int"
                }
              ],
              "return_type": "Dict",
              "line_number": 41,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_workout_journal",
              "docstring": "Get all workout sessions for the journal.",
              "parameters": [],
              "return_type": "List[Dict]",
              "line_number": 50,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_fatigue_data",
              "docstring": "Get and structure fatigue data for the dashboard.",
              "parameters": [],
              "return_type": "Dict[(str, List)]",
              "line_number": 59,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_goals_with_progress",
              "docstring": "Get active goals and calculate their progress percentage.",
              "parameters": [],
              "return_type": "List[Dict]",
              "line_number": 78,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "log_new_workout",
              "docstring": "Logs a new workout session and all of its sets in a single transaction.\nExpects workout_data to have 'session_date', 'notes', and a 'sets' list.",
              "parameters": [
                {
                  "name": "workout_data",
                  "type": "Dict"
                }
              ],
              "return_type": "int",
              "line_number": 98,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_fatigue_interpretation",
              "docstring": "Provides a human-readable interpretation of a given fatigue score.",
              "parameters": [
                {
                  "name": "score",
                  "type": "float"
                }
              ],
              "return_type": "str",
              "line_number": 132,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_acwr_to_fatigue_score",
              "docstring": "Converts an ACWR value to a 0-100 fatigue score. (No changes from before)",
              "parameters": [
                {
                  "name": "acwr",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 145,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_fatigue_dashboard_data",
              "docstring": "Calculates a comprehensive, time-decayed fatigue analysis for the dashboard.\n\nThis on-the-fly calculation includes:\n- Exponentially decayed workload for higher accuracy.\n- Fatigue scores for individual muscles, body groups, and overall.\n- Human-readable interpretations of all scores.\n- Data structured for categorical filtering (Overall, Lower, Upper, Core).",
              "parameters": [],
              "return_type": "Dict",
              "line_number": 153,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_exercise_max_weights",
              "docstring": "Get exercises with their maximum weights.",
              "parameters": [],
              "return_type": "List[Dict]",
              "line_number": 242,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_exercise_max_for_goals",
              "docstring": "Get maximum weight for a specific exercise for goals tracking.",
              "parameters": [
                {
                  "name": "exercise_id",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "line_number": 251,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 20,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "collections.defaultdict",
        "datetime.datetime",
        "datetime.timedelta",
        "math",
        "services.base_service.BaseService",
        "utils.exception_utils",
        "utils.db.runstrong_db_utils"
      ]
    },
    "statistics_service": {
      "file_path": "services\\statistics_service.py",
      "classes": [
        {
          "name": "StatisticsService",
          "docstring": "Service for generating running statistics.",
          "methods": [
            {
              "name": "get_statistics",
              "docstring": "Get comprehensive running statistics for a time period.",
              "parameters": [
                {
                  "name": "period",
                  "type": "str"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 23,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_period_start_date",
              "docstring": "Calculate start date based on period.",
              "parameters": [
                {
                  "name": "now",
                  "type": "datetime"
                },
                {
                  "name": "period",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "line_number": 62,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_date_range_label",
              "docstring": "Get human-readable date range label.",
              "parameters": [
                {
                  "name": "period",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "line_number": 73,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_summary_statistics",
              "docstring": "Get summary statistics for the period.",
              "parameters": [
                {
                  "name": "start_date",
                  "type": "str"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 83,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_weekly_distances",
              "docstring": "Get distances for the last 7 days.",
              "parameters": [
                {
                  "name": "now",
                  "type": "datetime"
                }
              ],
              "return_type": "List[float]",
              "line_number": 118,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_pace_trends",
              "docstring": "Get pace trends for the last 10 activities.",
              "parameters": [
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, List)]",
              "line_number": 143,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_shoe_usage",
              "docstring": "Get shoe usage statistics.",
              "parameters": [
                {
                  "name": "start_date",
                  "type": "str"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "List[Dict[(str, Any)]]",
              "line_number": 173,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_recent_activities",
              "docstring": "Get recent activities with formatted data.",
              "parameters": [
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "List[Dict[(str, Any)]]",
              "line_number": 203,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 20,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "json",
        "sqlite3",
        "datetime.datetime",
        "datetime.timedelta",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "dateutil.relativedelta.relativedelta",
        "services.base_service.BaseService",
        "utils.format_utils",
        "utils.exception_utils",
        "utils.db.db_utils",
        "utils.db.running_hub_db_utils"
      ]
    },
    "trophy_service": {
      "file_path": "services\\trophy_service.py",
      "classes": [
        {
          "name": "TrophyService",
          "docstring": "Service for managing personal records and achievements.",
          "methods": [
            {
              "name": "get_personal_records",
              "docstring": "Get all personal records for standard race distances.",
              "parameters": [
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "List[Dict[(str, Any)]]",
              "line_number": 20,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_format_record",
              "docstring": "Format a personal record for display.",
              "parameters": [
                {
                  "name": "activity",
                  "type": "Dict[(str, Any)]"
                },
                {
                  "name": "distance_name",
                  "type": "str"
                },
                {
                  "name": "units",
                  "type": "str"
                }
              ],
              "return_type": "Dict[(str, Any)]",
              "line_number": 66,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 17,
          "bases": [
            "BaseService"
          ]
        }
      ],
      "functions": [],
      "imports": [
        "sqlite3",
        "datetime.datetime",
        "datetime.timedelta",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "services.base_service.BaseService",
        "utils.format_utils",
        "utils.exception_utils",
        "utils.db.db_utils",
        "utils.db.running_hub_db_utils"
      ]
    }
  },
  "biomechanic_modules": {
    "reports\\rating_utils": {
      "file_path": "runnervision_utils\\reports\\rating_utils.py",
      "module_docstring": null,
      "classes": [],
      "functions": [
        {
          "name": "get_rating_from_score",
          "docstring": "Determines the rating category based on a score and defined thresholds.\n\nArgs:\n    score (float): The score to evaluate (0-100).\n    thresholds (dict): A dictionary with keys 'optimal', 'good', 'fair' defining the lower bound of each category.\n\nReturns:\n    tuple: A tuple containing the rating text (str) and rating key (str).",
          "parameters": [
            {
              "name": "score"
            },
            {
              "name": "thresholds"
            }
          ],
          "return_type": null,
          "line_number": 3,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rate_cadence",
          "docstring": "Rates running cadence (in steps per minute).",
          "parameters": [
            {
              "name": "cadence"
            }
          ],
          "return_type": null,
          "line_number": 22,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rate_trunk_angle",
          "docstring": "Rates forward trunk lean in degrees.",
          "parameters": [
            {
              "name": "angle"
            }
          ],
          "return_type": null,
          "line_number": 30,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rate_knee_symmetry",
          "docstring": "Rates knee symmetry based on percentage difference.",
          "parameters": [
            {
              "name": "diff_percent"
            }
          ],
          "return_type": null,
          "line_number": 38,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rate_crossover",
          "docstring": "Rates foot crossover percentage (lower is better).",
          "parameters": [
            {
              "name": "crossover_percent"
            }
          ],
          "return_type": null,
          "line_number": 48,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": []
    },
    "reports\\text_generation": {
      "file_path": "runnervision_utils\\reports\\text_generation.py",
      "module_docstring": null,
      "classes": [],
      "functions": [
        {
          "name": "generate_rear_view_summary_from_llm",
          "docstring": "Generates a text summary for the rear view analysis using a local language model\nand formats the markdown response into HTML.",
          "parameters": [
            {
              "name": "summary_data"
            },
            {
              "name": "lm_model"
            }
          ],
          "return_type": null,
          "line_number": 11,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "generate_side_view_summary_from_llm",
          "docstring": "Generates a text summary for the side view analysis using a local language model.\n\nArgs:\n    summary_data (dict): A dictionary of summarized metrics for the side view.\n\nReturns:\n    str: A raw markdown string with the generated analysis and recommendations.",
          "parameters": [
            {
              "name": "summary_data"
            },
            {
              "name": "lm_model"
            }
          ],
          "return_type": null,
          "line_number": 67,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "json",
        "logging",
        "markdown",
        "numpy",
        "utils.language_model_utils.LanguageModel"
      ]
    },
    "metrics\\rear\\gait_events_and_phases\\stance_phase_detector_rear": {
      "file_path": "runnervision_utils\\metrics\\rear\\gait_events_and_phases\\stance_phase_detector_rear.py",
      "module_docstring": "Rear-view stance phase detection for running biomechanics analysis.\n\nThis module provides functionality to detect stance phase (ground contact) during running\nfrom rear-view camera angles using MediaPipe Pose landmarks. The detector uses vertical\nfoot position relative to calibrated ground and swing zones to determine when feet are\nin contact with the ground.\n\nKey Features:\n- Automatic calibration from observed foot motion\n- Robust detection using multiple foot landmarks\n- Confidence scoring for detection reliability\n- Handles missing or low-visibility landmarks gracefully",
      "classes": [
        {
          "name": "StancePhaseDetectorRear",
          "docstring": "Detects stance phase from rear-view running analysis using foot landmark positions.\n\nThis detector works by:\n1. Calibrating ground and swing zones from observed foot motion\n2. Comparing current foot positions to these zones\n3. Determining which foot (if any) is in ground contact\n4. Providing confidence scores for detection reliability\n\nThe detector assumes normalized MediaPipe coordinates where:\n- Y=0 is top of frame, Y=1 is bottom of frame\n- Higher Y values indicate lower vertical positions (closer to ground)",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the rear-view stance phase detector.\n\nArgs:\n    calibration_frames_total: Number of frames for calibration phase.\n        Recommended: 90-150 frames (3-5 seconds at 30fps) to capture\n        full range of motion during running.\n    ground_zone_percentage: Percentage of foot's vertical range that defines\n        ground contact zone. Lower values = stricter ground detection.\n        Typical range: 0.10-0.25.\n    visibility_threshold: Minimum MediaPipe visibility score (0.0-1.0) \n        required for landmark to be considered reliable.\n    foot_landmarks_to_use: Custom landmark configuration for each foot.\n        If None, uses default foot_index and heel landmarks.\n        Format: {'left': ['landmark1', 'landmark2'], 'right': [...]}\n\nRaises:\n    ValueError: If parameters are outside valid ranges.",
              "parameters": [
                {
                  "name": "calibration_frames_total",
                  "type": "int"
                },
                {
                  "name": "ground_zone_percentage",
                  "type": "float"
                },
                {
                  "name": "visibility_threshold",
                  "type": "float"
                },
                {
                  "name": "foot_landmarks_to_use",
                  "type": "Optional[FootLandmarksConfig]"
                }
              ],
              "return_type": "None",
              "line_number": 47,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_lowest_point_of_foot",
              "docstring": "Get the lowest Y coordinate for a foot, considering landmark visibility.\n\nArgs:\n    landmarks: Dictionary of pose landmarks\n    side_key: 'left' or 'right' foot identifier\n    \nReturns:\n    Lowest (highest Y value) visible point of the foot, or None if no\n    landmarks are visible above threshold.\n    \nNote:\n    In normalized coordinates, max(Y) represents the lowest visual point\n    since Y increases downward from top of frame.",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                },
                {
                  "name": "side_key",
                  "type": "str"
                }
              ],
              "return_type": "Optional[float]",
              "line_number": 105,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_collect_calibration_data",
              "docstring": "Collect foot position data during calibration phase.\n\nStores the lowest point of each visible foot to build understanding\nof the runner's range of motion and ground contact patterns.\n\nArgs:\n    landmarks: Current frame's pose landmarks",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "None",
              "line_number": 138,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_finalize_calibration",
              "docstring": "Calculate detection thresholds from collected calibration data.\n\nUses robust statistical methods (percentiles) to establish:\n- Ground level (where feet contact during stance)\n- Peak swing level (highest point during swing phase)  \n- Ground contact threshold (boundary for stance detection)\n\nHandles edge cases like insufficient data or minimal foot motion.",
              "parameters": [],
              "return_type": "None",
              "line_number": 157,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_set_default_calibration_values",
              "docstring": "Set reasonable default values when calibration fails or has insufficient data.",
              "parameters": [],
              "return_type": "None",
              "line_number": 207,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_validate_and_adjust_calibration",
              "docstring": "Ensure calibration values are reasonable and adjust if necessary.\n\nChecks that ground level is actually lower than peak swing level,\nand adjusts if the detected range seems inverted or too small.",
              "parameters": [],
              "return_type": "None",
              "line_number": 217,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_stance_confidence",
              "docstring": "Calculate confidence score for stance/flight detection.\n\nArgs:\n    foot_y: Y position of the foot in question\n    is_in_stance: Whether foot is detected as being in stance\n    other_foot_y: Y position of other foot (for flight confidence calculation)\n    \nReturns:\n    Confidence score between 0.0-1.0, where:\n    - 0.5+ indicates stance phase confidence\n    - <0.5 indicates flight phase confidence\n    - Higher values = more confident",
              "parameters": [
                {
                  "name": "foot_y",
                  "type": "float"
                },
                {
                  "name": "is_in_stance",
                  "type": "bool"
                },
                {
                  "name": "other_foot_y",
                  "type": "Optional[float]"
                }
              ],
              "return_type": "float",
              "line_number": 239,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "detect_stance_phase",
              "docstring": "Detect stance phase from current frame landmarks.\n\nArgs:\n    landmarks: Dictionary of MediaPipe pose landmarks with format:\n              {landmark_name: (x, y, z, visibility), ...}\n              \nReturns:\n    Dictionary containing:\n    - 'is_stance_phase' (bool): True if either foot is in ground contact\n    - 'stance_foot' (str|None): 'left', 'right', or None\n    - 'confidence' (float): Detection confidence score (0.0-1.0)\n    - 'debug' (str, optional): Debug information for troubleshooting\n    \nNote:\n    During calibration phase, always returns is_stance_phase=False\n    with debug info indicating calibration status.",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "StanceResult",
              "line_number": 276,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset_calibration",
              "docstring": "Reset calibration state to allow re-calibration with new data.\n\nUseful when switching between different runners or significantly\ndifferent running conditions.",
              "parameters": [],
              "return_type": "None",
              "line_number": 380,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "is_calibrated",
              "docstring": "Check if detector has completed calibration.",
              "parameters": [],
              "return_type": "bool",
              "line_number": 395,
              "is_async": false,
              "decorators": [
                "property"
              ]
            },
            {
              "name": "get_calibration_info",
              "docstring": "Get current calibration parameters and status.\n\nReturns:\n    Dictionary with calibration state information for debugging\n    and validation purposes.",
              "parameters": [],
              "return_type": "Dict[(str, Any)]",
              "line_number": 400,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 32,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "detect_stance_phase_rear",
          "docstring": "Convenience wrapper function for rear-view stance phase detection.\n\nThis function provides a simple interface for stance detection while managing\nthe detector instance lifecycle. It's designed to be called frame-by-frame\nin a video processing pipeline.\n\nArgs:\n    landmarks: Dictionary of MediaPipe pose landmarks for current frame\n    detector_instance: Optional pre-configured detector instance. If None,\n                     a new detector with default settings will be created\n                     and stored for subsequent calls.\n                     \nReturns:\n    Stance detection results dictionary (see StancePhaseDetectorRear.detect_stance_phase)\n    \nExample:\n    >>> landmarks = get_mediapipe_landmarks(frame)\n    >>> result = detect_stance_phase_rear(landmarks)\n    >>> if result['is_stance_phase']:\n    >>>     print(f\"Stance foot: {result['stance_foot']}, confidence: {result['confidence']}\")\n    \nNote:\n    This wrapper maintains a single detector instance across calls using a\n    function attribute. For multiple concurrent analyses, create separate\n    StancePhaseDetectorRear instances directly.",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "detector_instance",
              "type": "Optional[StancePhaseDetectorRear]"
            }
          ],
          "return_type": "StanceResult",
          "line_number": 421,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Any",
        "typing.Union"
      ]
    },
    "metrics\\rear\\gait_events_and_phases\\step_width": {
      "file_path": "runnervision_utils\\metrics\\rear\\gait_events_and_phases\\step_width.py",
      "module_docstring": null,
      "classes": [],
      "functions": [
        {
          "name": "calculate_step_width",
          "docstring": "Distance between both feet.",
          "parameters": [
            {
              "name": "landmarks"
            }
          ],
          "return_type": null,
          "line_number": 3,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": []
    },
    "metrics\\rear\\gait_events_and_phases\\stride_symmetry": {
      "file_path": "runnervision_utils\\metrics\\rear\\gait_events_and_phases\\stride_symmetry.py",
      "module_docstring": null,
      "classes": [],
      "functions": [
        {
          "name": "calculate_stride_symmetry",
          "docstring": "Compare stride or timing parameters over a cycle (requires frame history).\nPlaceholder uses foot x-delta.",
          "parameters": [
            {
              "name": "landmarks"
            }
          ],
          "return_type": null,
          "line_number": 3,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": []
    },
    "metrics\\rear\\lower_body\\ankle_inversion": {
      "file_path": "runnervision_utils\\metrics\\rear\\lower_body\\ankle_inversion.py",
      "module_docstring": "Calculates ankle inversion/eversion patterns during running gait analysis.\n\nThis metric helps identify biomechanical inefficiencies related to foot strike\npatterns that may lead to injury. Excessive inversion is linked to lateral ankle\nsprains and insufficient shock absorption, while excessive eversion is associated\nwith medial tibial stress syndrome (shin splints) and plantar fasciitis.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_ankle_inversion",
          "docstring": "Measures ankle inversion/eversion patterns during running from rear view analysis.\n\nInversion occurs when the ankle rolls outward (supination), while eversion \noccurs when the ankle rolls inward (pronation). Measurements are normalized\nby hip width for consistent comparison across different body types.\n\nFrom rear view perspective:\n- Left foot: heel left of ankle = inversion, heel right of ankle = eversion\n- Right foot: heel right of ankle = inversion, heel left of ankle = eversion\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing 3D coordinates and visibility of detected pose landmarks.\n    Expected keys: 'left_hip', 'right_hip', 'left_ankle', 'right_ankle',\n                  'left_heel', 'right_heel'.\n    Optional keys: 'left_foot_index', 'right_foot_index' for enhanced analysis.\n    Each landmark is a tuple: (x, y, z, visibility).\n\ninversion_threshold : float, default=0.03\n    Threshold as proportion of hip width for classifying inversion/eversion.\n    Values above this threshold indicate abnormal patterns.\n    Clinical standard is approximately 3% of hip width.\n\nReturns:\n--------\nAnkleInversionResult\n    Dictionary containing:\n    - \"left_inversion_value\" (Optional[float]): Raw inversion measurement for left foot.\n        Positive = inversion, negative = eversion. None if calculation fails.\n    - \"right_inversion_value\" (Optional[float]): Raw inversion measurement for right foot.\n        Positive = inversion, negative = eversion. None if calculation fails.\n    - \"left_normalized\" (Optional[float]): Left inversion normalized by hip width.\n        None if calculation fails.\n    - \"right_normalized\" (Optional[float]): Right inversion normalized by hip width.\n        None if calculation fails.\n    - \"left_pattern\" (Optional[str]): Classification as \"inversion\", \"eversion\", or \"neutral\".\n        None if calculation fails.\n    - \"right_pattern\" (Optional[str]): Classification as \"inversion\", \"eversion\", or \"neutral\".\n        None if calculation fails.\n    - \"left_severity\" (Optional[str]): Severity level: \"normal\", \"mild\", \"moderate\", \"severe\".\n        None if calculation fails.\n    - \"right_severity\" (Optional[str]): Severity level: \"normal\", \"mild\", \"moderate\", \"severe\".\n        None if calculation fails.\n    - \"left_foot_angle\" (Optional[float]): Foot axis angle in degrees if toe landmarks available.\n        None if landmarks unavailable or calculation fails.\n    - \"right_foot_angle\" (Optional[float]): Foot axis angle in degrees if toe landmarks available.\n        None if landmarks unavailable or calculation fails.\n    - \"calculation_successful\" (bool): True if core metrics calculated, False otherwise.",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "inversion_threshold",
              "type": "float"
            }
          ],
          "return_type": "AnkleInversionResult",
          "line_number": 23,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_pattern",
          "docstring": "Classify inversion pattern based on normalized value.",
          "parameters": [
            {
              "name": "normalized_value",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 159,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_severity",
          "docstring": "Determine severity level based on normalized value.",
          "parameters": [
            {
              "name": "normalized_value",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 168,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\rear\\lower_body\\foot_crossover": {
      "file_path": "runnervision_utils\\metrics\\rear\\lower_body\\foot_crossover.py",
      "module_docstring": "Calculates foot crossover and distance from the body's midline.\n\nThis metric helps identify if a runner's feet are crossing the midline\nor landing too close to it, which can be indicative of certain biomechanical\ninefficiencies or an increased risk of injury.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_foot_crossover",
          "docstring": "Checks for feet being too close to or crossing the body's midline (from rear view).\n\nThe midline is calculated as the center point between the hips. Distances are\nnormalized by hip width. Crossover is determined if a foot is within a certain\nproportional distance (threshold_proportion) of the midline on its own side,\nor if it has crossed to the other side.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    A dictionary containing the 3D coordinates and visibility of detected pose landmarks.\n    Expected keys for this function: 'left_hip', 'right_hip', \n                                    'left_foot_index', 'right_foot_index'.\n    Each landmark is a tuple: (x, y, z, visibility). Coordinates are typically normalized (0.0-1.0).\n\nthreshold_proportion : float, default=0.25\n    The proportion of hip width used as a threshold. If a foot is closer to the\n    midline than this proportion of the hip width (on its own side), or has\n    crossed the midline, it's flagged as a crossover.\n    Lower values are stricter (less deviation from a wider track allowed).\n\nReturns:\n--------\nFootCrossoverResult\n    A dictionary containing:\n    - \"left_foot_crossover\" (Optional[bool]): True if the left foot crosses or is too close to midline, else False. None if calculation fails.\n    - \"right_foot_crossover\" (Optional[bool]): True if the right foot crosses or is too close, else False. None if calculation fails.\n    - \"left_distance_from_midline\" (Optional[float]): The X-axis distance of the left foot from the hip center.\n        Negative values indicate the foot is to the viewer's left of the midline.\n        Positive values indicate the foot is to the viewer's right of the midline.\n        None if calculation fails.\n    - \"right_distance_from_midline\" (Optional[float]): The X-axis distance of the right foot from the hip center.\n        Interpreted same as left_distance_from_midline.\n        None if calculation fails.\n    - \"calculation_successful\" (bool): True if metrics were calculated, False if essential landmarks were missing.",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "threshold_proportion",
              "type": "float"
            }
          ],
          "return_type": "FootCrossoverResult",
          "line_number": 24,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\rear\\lower_body\\hip_drop": {
      "file_path": "runnervision_utils\\metrics\\rear\\lower_body\\hip_drop.py",
      "module_docstring": "Calculates hip drop (Trendelenburg gait) during running analysis.\nThis metric identifies lateral pelvic tilt during single-leg support phases,\nwhich can indicate hip abductor weakness and potential injury risk.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_hip_drop",
          "docstring": "Detect hip drop (Trendelenburg gait) during running stance phase.\n\nHip drop occurs when the pelvis tilts laterally during single-leg support,\nindicating potential weakness in hip abductor muscles (primarily gluteus medius).\nThis analysis is most accurate when applied to frames during single-leg stance\nphases rather than flight phases.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    A dictionary containing the 3D coordinates and visibility of detected pose landmarks.\n    Expected keys for this function: 'left_hip', 'right_hip'.\n    Each landmark is a tuple: (x, y, z, visibility). Coordinates are typically \n    normalized (0.0-1.0) relative to image dimensions.\n    \nthreshold : float, default=0.015\n    The minimum difference in normalized hip height to classify as hip drop.\n    Represents approximately 1-2% of image height. Should be adjusted based on:\n    - Camera angle and distance from subject\n    - Image resolution and quality\n    - Clinical sensitivity requirements\n    \nReturns:\n--------\nHipDropResult\n    A dictionary containing:\n    - \"hip_drop_value\" (Optional[float]): Raw hip height difference in normalized coordinates.\n        Positive values indicate right hip is lower (dropped).\n        Negative values indicate left hip is lower (dropped).\n        None if calculation fails.\n    - \"hip_drop_direction\" (Optional[str]): Direction of hip drop (\"left\", \"right\", \"neutral\").\n        None if calculation fails.\n    - \"severity\" (Optional[str]): Clinical severity classification (\"none\", \"mild\", \"moderate\", \"severe\").\n        None if calculation fails.\n    - \"calculation_successful\" (bool): True if metrics were calculated, False if essential landmarks were missing.\n    \nNotes:\n------\nClinical severity thresholds (approximate conversions from degrees to normalized coordinates):\n- None/Neutral: < 1.5% image height (< ~2\u00b0)\n- Mild: 1.5-3% image height (~2-5\u00b0)\n- Moderate: 3-5% image height (~5-8\u00b0)\n- Severe: > 5% image height (> ~8\u00b0)\n\nThese thresholds assume typical camera positioning and may need adjustment\nfor different recording setups or clinical protocols.\n\nBest Practice:\n- Apply this analysis only during identified single-leg stance phases\n- Consider multiple frames/cycles for reliable assessment\n- Account for natural body asymmetries in interpretation",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "threshold",
              "type": "float"
            }
          ],
          "return_type": "HipDropResult",
          "line_number": 17,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_hip_drop_sequence",
          "docstring": "Analyze hip drop across a sequence of frames, optionally filtering for stance phases.\n\nParameters:\n-----------\nlandmark_sequence : list[LandmarksDict]\n    List of landmark dictionaries for each frame\nthreshold : float, default=0.015\n    Hip drop detection threshold\nstance_phases : Optional[list[bool]], default=None\n    Boolean list indicating stance phases. If provided, only stance phase\n    frames will be analyzed. Should match length of landmark_sequence.\n    \nReturns:\n--------\nDict[str, Any]\n    Summary statistics including mean, max, and frame-by-frame results",
          "parameters": [
            {
              "name": "landmark_sequence",
              "type": "list[LandmarksDict]"
            },
            {
              "name": "threshold",
              "type": "float"
            },
            {
              "name": "stance_phases",
              "type": "Optional[list[bool]]"
            }
          ],
          "return_type": "Dict[(str, Any)]",
          "line_number": 142,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\rear\\lower_body\\knee_alignment": {
      "file_path": "runnervision_utils\\metrics\\rear\\lower_body\\knee_alignment.py",
      "module_docstring": "Calculates knee alignment patterns during running to detect valgus (knock-knee) \nor varus (bow-leg) deviations that may indicate injury risk factors.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_knee_alignment",
          "docstring": "Assess knee alignment during running to detect valgus (knock-knee) or varus (bow-leg) patterns.\n\nDynamic knee valgus is particularly concerning in runners as it indicates:\n- Potential weakness in hip abductors/external rotators\n- Excessive foot pronation\n- Risk factor for patellofemoral pain syndrome, ACL injuries, and IT band syndrome\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    A dictionary containing the 3D coordinates and visibility of detected pose landmarks.\n    Expected keys: 'left_hip', 'left_knee', 'left_ankle', 'right_hip', 'right_knee', 'right_ankle'.\n    Each landmark is a tuple: (x, y, z, visibility).\n    \nthreshold : float, default=0.1\n    Threshold as proportion of hip width for classification (0.1 = 10% of hip width).\n    Values above this threshold indicate concerning alignment deviation.\n    \nReturns:\n--------\nKneeAlignmentResult\n    A dictionary containing:\n    - \"left_knee_valgus\" (Optional[bool]): True if left knee shows valgus pattern. None if calculation fails.\n    - \"left_knee_varus\" (Optional[bool]): True if left knee shows varus pattern. None if calculation fails.\n    - \"right_knee_valgus\" (Optional[bool]): True if right knee shows valgus pattern. None if calculation fails.\n    - \"right_knee_varus\" (Optional[bool]): True if right knee shows varus pattern. None if calculation fails.\n    - \"left_normalized_deviation\" (Optional[float]): Left knee deviation normalized by hip width. None if calculation fails.\n    - \"right_normalized_deviation\" (Optional[float]): Right knee deviation normalized by hip width. None if calculation fails.\n    - \"severity_left\" (Optional[str]): Clinical severity for left knee (\"normal\", \"mild\", \"moderate\", \"severe\"). None if calculation fails.\n    - \"severity_right\" (Optional[str]): Clinical severity for right knee (\"normal\", \"mild\", \"moderate\", \"severe\"). None if calculation fails.\n    - \"calculation_successful\" (bool): True if metrics were calculated, False if essential landmarks were missing.\n    \nNotes:\n------\nAlignment assessment (from posterior view):\n- Valgus (knock-knee): Knee deviates toward midline\n- Varus (bow-leg): Knee deviates away from midline\n\nSeverity thresholds (as proportion of hip width):\n- Normal: < 10% deviation\n- Mild: 10-15% deviation\n- Moderate: 15-20% deviation  \n- Severe: > 20% deviation\n\nBest Practice:\n- Analyze during single-leg stance phases for most accurate assessment\n- Consider multiple gait cycles for reliable patterns\n- Account for natural anatomical variations",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "threshold",
              "type": "float"
            }
          ],
          "return_type": "KneeAlignmentResult",
          "line_number": 16,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_knee_alignment_sequence",
          "docstring": "Analyze knee alignment across multiple frames with optional stance phase filtering.\n\nParameters:\n-----------\nlandmark_sequence : list[LandmarksDict]\n    List of landmark dictionaries for each frame\nthreshold : float, default=0.1\n    Alignment deviation threshold\nstance_phases : Optional[list[bool]], default=None\n    Boolean list for stance phase filtering\n    \nReturns:\n--------\nDict[str, Any]\n    Summary statistics and frame-by-frame results",
          "parameters": [
            {
              "name": "landmark_sequence",
              "type": "list[LandmarksDict]"
            },
            {
              "name": "threshold",
              "type": "float"
            },
            {
              "name": "stance_phases",
              "type": "Optional[list[bool]]"
            }
          ],
          "return_type": "Dict[(str, Any)]",
          "line_number": 177,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_severity",
          "docstring": null,
          "parameters": [
            {
              "name": "deviation",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 141,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\rear\\lower_body\\pelvic_tilt": {
      "file_path": "runnervision_utils\\metrics\\rear\\lower_body\\pelvic_tilt.py",
      "module_docstring": "Calculates lateral pelvic tilt angle in the frontal plane during running analysis.\nThis metric identifies pelvic orientation deviations that can indicate hip abductor\nweakness, leg length discrepancies, or compensation patterns.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_pelvic_tilt",
          "docstring": "Calculate lateral pelvic tilt angle in the frontal plane during running.\n\nMeasures lateral pelvic tilt (frontal plane) which can indicate:\n- Hip abductor weakness (primarily gluteus medius)\n- Leg length discrepancy (functional or anatomical)\n- Compensation patterns for other biomechanical issues\n- Potential IT band, low back, or knee injury risk\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    A dictionary containing the 3D coordinates and visibility of detected pose landmarks.\n    Expected keys for this function: 'left_hip', 'right_hip'.\n    Each landmark is a tuple: (x, y, z, visibility). Coordinates are typically \n    normalized (0.0-1.0) relative to image dimensions.\n    \ncoordinate_system : str, default=\"vision_standard\"\n    Coordinate system convention:\n    - \"vision_standard\": Y increases downward (typical for computer vision)\n    - \"clinical_standard\": Y increases upward (typical for clinical analysis)\n    \nReturns:\n--------\nPelvicTiltResult\n    A dictionary containing:\n    - \"tilt_angle_degrees\" (Optional[float]): Lateral pelvic tilt angle in degrees.\n        Positive values indicate right side elevated.\n        Negative values indicate left side elevated.\n        None if calculation fails.\n    - \"elevated_side\" (Optional[str]): Side that is elevated (\"left\", \"right\", \"neutral\").\n        None if calculation fails.\n    - \"severity\" (Optional[str]): Clinical severity classification (\"normal\", \"mild\", \"moderate\", \"severe\").\n        None if calculation fails.\n    - \"normalized_tilt\" (Optional[float]): Tilt normalized by hip distance for relative assessment.\n        None if calculation fails.\n    - \"calculation_successful\" (bool): True if metrics were calculated, False if essential landmarks were missing.\n    \nNotes:\n------\nClinical severity thresholds:\n- Normal range: \u00b12\u00b0 during stance phase\n- Mild tilt: 2-5\u00b0 (potential early intervention)\n- Moderate: 5-10\u00b0 (intervention recommended)  \n- Severe: >10\u00b0 (significant dysfunction)\n\nThis measures frontal plane motion only and differs from anterior/posterior pelvic tilt\n(sagittal plane), which requires side-view analysis.\n\nBest Practice:\n- Apply during single-leg stance phases for most accurate assessment\n- Consider multiple cycles for reliable clinical interpretation\n- Account for camera positioning and potential parallax effects",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "coordinate_system",
              "type": "str"
            }
          ],
          "return_type": "PelvicTiltResult",
          "line_number": 18,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_pelvic_tilt_sequence",
          "docstring": "Analyze pelvic tilt across a sequence of frames, optionally filtering for stance phases.\n\nParameters:\n-----------\nlandmark_sequence : list[LandmarksDict]\n    List of landmark dictionaries for each frame\ncoordinate_system : str, default=\"vision_standard\"\n    Coordinate system convention for tilt calculation\nstance_phases : Optional[list[bool]], default=None\n    Boolean list indicating stance phases for filtering\n    \nReturns:\n--------\nDict[str, Any]\n    Summary statistics and frame-by-frame results",
          "parameters": [
            {
              "name": "landmark_sequence",
              "type": "list[LandmarksDict]"
            },
            {
              "name": "coordinate_system",
              "type": "str"
            },
            {
              "name": "stance_phases",
              "type": "Optional[list[bool]]"
            }
          ],
          "return_type": "Dict[(str, Any)]",
          "line_number": 160,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\rear\\upper_body\\arm_swing_mechanics": {
      "file_path": "runnervision_utils\\metrics\\rear\\upper_body\\arm_swing_mechanics.py",
      "module_docstring": "Analyzes arm swing mechanics during running from rear view perspective.\n\nEfficient arm swing should move primarily in the sagittal plane, maintain\nsymmetrical timing and amplitude, preserve ~90\u00b0 elbow flexion, counter-rotate\nwith opposite leg, and avoid excessive midline crossing. Poor mechanics can\nlead to energy inefficiency and compensatory movement patterns.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_arm_swing_mechanics",
          "docstring": "Analyzes arm swing mechanics during running from rear view perspective.\n\nEvaluates vertical symmetry, elbow angles, crossover patterns, and shoulder\nstability. Measurements are normalized by hip width for consistent comparison\nacross body types.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing 3D coordinates and visibility of detected landmarks.\n    Required keys: 'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow',\n                  'left_wrist', 'right_wrist', 'left_hip', 'right_hip'.\n    Each landmark is a tuple: (x, y, z, visibility).\n\nsymmetry_threshold : float, default=0.05\n    Threshold as proportion of hip width for assessing arm height symmetry.\n    Values above indicate asymmetrical arm positioning.\n\nrotation_threshold : float, default=0.03\n    Threshold as proportion of hip width for detecting excessive shoulder rotation.\n    Values above indicate unstable shoulder mechanics.\n\nReturns:\n--------\nArmSwingResult\n    Dictionary containing:\n    - \"vertical_elbow_diff\" (Optional[float]): Absolute vertical difference between elbows.\n    - \"normalized_vertical_diff\" (Optional[float]): Vertical difference normalized by hip width.\n    - \"left_elbow_angle\" (Optional[float]): Left elbow flexion angle in degrees.\n    - \"right_elbow_angle\" (Optional[float]): Right elbow flexion angle in degrees.\n    - \"normalized_shoulder_diff\" (Optional[float]): Shoulder height difference normalized by hip width.\n    - \"normalized_shoulder_width\" (Optional[float]): Shoulder width normalized by hip width.\n    - \"arm_height_symmetry\" (Optional[str]): Classification: \"good\", \"moderate\", \"poor\".\n    - \"elbow_angle_left\" (Optional[str]): Classification: \"optimal\", \"too_straight\", \"too_bent\".\n    - \"elbow_angle_right\" (Optional[str]): Classification: \"optimal\", \"too_straight\", \"too_bent\".\n    - \"left_wrist_crossover\" (Optional[bool]): True if left wrist crosses midline.\n    - \"right_wrist_crossover\" (Optional[bool]): True if right wrist crosses midline.\n    - \"shoulder_rotation\" (Optional[str]): Classification: \"stable\", \"excessive\".\n    - \"calculation_successful\" (bool): True if metrics calculated successfully.",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "symmetry_threshold",
              "type": "float"
            },
            {
              "name": "rotation_threshold",
              "type": "float"
            }
          ],
          "return_type": "ArmSwingResult",
          "line_number": 23,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "calculate_angle",
          "docstring": "Calculate angle between three points (b is the vertex).",
          "parameters": [
            {
              "name": "a",
              "type": "Landmark"
            },
            {
              "name": "b",
              "type": "Landmark"
            },
            {
              "name": "c",
              "type": "Landmark"
            }
          ],
          "return_type": "float",
          "line_number": 126,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "classify_arm_symmetry",
          "docstring": "Classify arm height symmetry.",
          "parameters": [
            {
              "name": "norm_diff",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 155,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "classify_elbow_angle",
          "docstring": "Classify elbow angle optimality.",
          "parameters": [
            {
              "name": "angle",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 164,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "classify_shoulder_rotation",
          "docstring": "Classify shoulder rotation stability.",
          "parameters": [
            {
              "name": "norm_diff",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 173,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\side\\gait_events_and_phases\\ground_contact_time": {
      "file_path": "runnervision_utils\\metrics\\side\\gait_events_and_phases\\ground_contact_time.py",
      "module_docstring": "Analyzes ground contact time and related metrics for running gait analysis.\n\nThis module tracks foot contact with the ground over time to calculate:\n- Ground contact duration for each foot\n- Contact time asymmetry between feet\n- Running cadence\n- Efficiency ratings based on contact time\n\nGround contact is determined by analyzing foot height relative to an estimated\nground level over a sliding window of frames.",
      "classes": [
        {
          "name": "GroundContactTimeAnalyzer",
          "docstring": "Analyzes ground contact time for running gait analysis.\n\nThis class maintains internal history of foot positions and contact states\nto calculate ground contact metrics over time. It uses a sliding window\napproach to estimate ground level and detect contact/lift-off events.\n\nThe analyzer tracks:\n- Individual foot contact durations\n- Contact time asymmetry between feet  \n- Running cadence (steps per minute)\n- Efficiency ratings based on contact time benchmarks\n\nAttributes:\n    frame_rate (float): Video frame rate in fps\n    history_size (int): Number of frames to maintain for analysis\n    foot_height_threshold (float): Height threshold for contact detection\n    frame_count (int): Total frames processed\n    step_count (int): Total steps detected across both feet",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the ground contact time analyzer.\n\nArgs:\n    frame_rate: Video frame rate in fps. Used for time calculations.\n    history_size: Number of frames to maintain in sliding window for \n                 ground level estimation and contact analysis.\n    foot_height_threshold: Normalized height threshold above estimated \n                         ground level for determining foot contact.\n                         Smaller values are more sensitive.\n\nRaises:\n    ValueError: If parameters are outside valid ranges.",
              "parameters": [
                {
                  "name": "frame_rate",
                  "type": "float"
                },
                {
                  "name": "history_size",
                  "type": "int"
                },
                {
                  "name": "foot_height_threshold",
                  "type": "float"
                }
              ],
              "return_type": null,
              "line_number": 51,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "update",
              "docstring": "Update analyzer with new frame data and calculate ground contact metrics.\n\nProcesses a new frame of landmark data to:\n1. Extract foot positions\n2. Update contact state tracking\n3. Detect contact/lift-off transitions\n4. Calculate current metrics\n\nArgs:\n    landmarks: Dictionary containing pose landmarks. Must include \n              'left_ankle' and 'right_ankle' keys with (x,y,z,visibility) tuples.\n              Y-coordinates should be normalized (0.0-1.0) with 0 at top.\n\nReturns:\n    GroundContactResult: Dictionary containing calculated metrics:\n        - left_foot_contact_time_ms: Average left foot contact time\n        - right_foot_contact_time_ms: Average right foot contact time  \n        - avg_contact_time_ms: Overall average contact time\n        - contact_time_ratio: Left/right contact time ratio\n        - efficiency_rating: Qualitative efficiency assessment\n        - cadence_spm: Running cadence in steps per minute\n        - total_steps_detected: Total steps counted\n        - data_quality: 'sufficient' or 'insufficient'\n        - calculation_successful: True if calculation completed",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "GroundContactResult",
              "line_number": 106,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_estimate_ground_level",
              "docstring": "Estimate ground level from recent foot height positions.\n\nUses the 10th percentile of recent foot positions as ground level\nestimate, which is robust to outliers and gait variations.\n\nArgs:\n    foot_heights: Deque of recent foot height values\n    \nReturns:\n    float: Estimated ground level (y-coordinate)",
              "parameters": [
                {
                  "name": "foot_heights",
                  "type": "deque"
                }
              ],
              "return_type": "float",
              "line_number": 193,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_update_contact_tracking",
              "docstring": "Track contact period transitions for each foot.\n\nDetects contact start/end events and calculates contact durations.\nUpdates step count and contact time history.\n\nArgs:\n    foot: Either 'left' or 'right'\n    is_contact: Current contact state for the specified foot",
              "parameters": [
                {
                  "name": "foot",
                  "type": "str"
                },
                {
                  "name": "is_contact",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "line_number": 215,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_metrics",
              "docstring": "Calculate comprehensive ground contact time metrics.\n\nComputes averages, ratios, cadence, and efficiency ratings from\nthe accumulated contact time data.\n\nReturns:\n    GroundContactResult: Dictionary of calculated metrics",
              "parameters": [],
              "return_type": "GroundContactResult",
              "line_number": 261,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_assess_efficiency",
              "docstring": "Determine running efficiency rating based on ground contact time.\n\nBased on research indicating that elite runners typically have\nshorter ground contact times:\n- Excellent: \u2264180ms (elite level)\n- Good: 181-220ms (competitive recreational)  \n- Moderate: 221-280ms (recreational)\n- Poor: >280ms (inefficient)\n\nArgs:\n    contact_time_ms: Average ground contact time in milliseconds\n    \nReturns:\n    str: Efficiency rating category",
              "parameters": [
                {
                  "name": "contact_time_ms",
                  "type": "float"
                }
              ],
              "return_type": "str",
              "line_number": 311,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset",
              "docstring": "Reset the analyzer state for processing a new sequence.\n\nClears all accumulated data while preserving configuration parameters.\nUseful when starting analysis of a new video or runner.",
              "parameters": [],
              "return_type": "None",
              "line_number": 337,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 29,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "ground_contact_wrapper",
          "docstring": "Standalone wrapper function for ground contact analysis.\n\nProvides a functional interface to the GroundContactTimeAnalyzer class\nfor integration with existing analysis pipelines.\n\nArgs:\n    analyzer: Initialized GroundContactTimeAnalyzer instance\n    landmarks: Dictionary containing pose landmarks\n    \nReturns:\n    GroundContactResult: Analysis results from the analyzer",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "detector_instance",
              "type": "Optional[GroundContactTimeAnalyzer]"
            }
          ],
          "return_type": "GroundContactResult",
          "line_number": 360,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "collections.deque",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any",
        "typing.Union",
        "math"
      ]
    },
    "metrics\\side\\gait_events_and_phases\\stance_phase_detector_side": {
      "file_path": "runnervision_utils\\metrics\\side\\gait_events_and_phases\\stance_phase_detector_side.py",
      "module_docstring": "Side-view stance phase detection for running biomechanics analysis.\n\nThis module provides stance phase detection capabilities for runners captured from \na side view using MediaPipe BlazePose landmarks. The detector uses ground contact \nproximity and optional velocity analysis to determine when each foot is in contact \nwith the ground during the running gait cycle.\n\nKey Features:\n- Automatic calibration of ground level and runner dimensions\n- Dynamic threshold adjustment based on runner's apparent height\n- Confidence scoring for stance phase predictions\n- Support for both left and right foot detection\n- Robust handling of landmark visibility variations\n\nBiomechanical Context:\n- Stance phase: Period when foot is in contact with ground (~40% of gait cycle)\n- Flight phase: Period when both feet are airborne (~60% of gait cycle)\n- Critical for analyzing ground reaction forces, impact loading, and propulsion",
      "classes": [
        {
          "name": "StancePhaseDetectorSide",
          "docstring": "Detects stance phase from side-view running footage using MediaPipe BlazePose landmarks.\n\nThis detector performs automatic calibration during initial frames to establish ground\nlevel and runner dimensions, then uses proximity-based detection with optional velocity\nanalysis to determine foot-ground contact phases.\n\nThe detection algorithm accounts for:\n- Varying runner heights and camera distances through dynamic scaling\n- Landmark visibility variations in real-world footage  \n- Single vs double stance phases (rare in running but possible at transitions)\n- Confidence scoring based on detection certainty\n\nAttributes:\n    calibration_frames (int): Number of frames used for initial calibration\n    stance_threshold_ratio (float): Stance detection sensitivity as ratio of runner height\n    visibility_threshold (float): Minimum landmark visibility score (0.0-1.0)\n    ground_level_normalized (Optional[float]): Calibrated ground Y-coordinate\n    avg_runner_height_normalized (Optional[float]): Calibrated runner height in normalized coords\n    frame_count (int): Current frame number for calibration tracking",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the stance phase detector with calibration parameters.\n\nParameters:\n-----------\ncalibration_frames : int, default=90\n    Number of initial frames used for ground level and runner height calibration.\n    More frames provide better calibration but delay analysis start. \n    90 frames \u2248 3 seconds at 30fps.\n    \nstance_threshold_ratio : float, default=0.018\n    Sensitivity threshold for stance detection as ratio of runner's apparent height.\n    Smaller values = stricter detection (foot must be very close to ground).\n    Typical range: 0.01-0.03 (1-3% of runner height).\n    \nvisibility_threshold : float, default=0.5\n    Minimum MediaPipe landmark visibility score for landmark to be considered valid.\n    Range: 0.0-1.0, where 1.0 = fully visible, 0.0 = not detected.\n    \nNote:\n-----\nAll coordinate calculations assume normalized MediaPipe coordinates (0.0-1.0)\nwhere (0,0) is top-left and (1,1) is bottom-right of the image frame.",
              "parameters": [
                {
                  "name": "calibration_frames",
                  "type": "int"
                },
                {
                  "name": "stance_threshold_ratio",
                  "type": "float"
                },
                {
                  "name": "visibility_threshold",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "line_number": 61,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "detect_stance_phase_side",
              "docstring": "Detect stance phase from side-view MediaPipe landmarks.\n\nThis is the main detection method that handles calibration during initial frames,\nthen performs stance phase analysis for subsequent frames.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary of MediaPipe pose landmarks with format:\n    {landmark_name: (x, y, z, visibility), ...}\n    Required landmarks: foot landmarks (heel, foot_index) and head landmarks\n    \nReturns:\n--------\nStanceResult\n    Dictionary containing:\n    - 'is_stance_phase' (bool): True if any foot is in stance phase\n    - 'stance_foot' (str|None): Which foot is in stance ('left', 'right', or None)\n    - 'confidence' (float): Detection confidence score (0.0-1.0)\n    - 'debug_info' (str): Status information for calibration/debugging\n    \nNote:\n-----\nDuring calibration phase (first N frames), returns is_stance_phase=False\nwith debug_info indicating calibration status.",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "StanceResult",
              "line_number": 132,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_collect_calibration_data",
              "docstring": "Collect ground level and runner height data during calibration frames.\n\nThis method accumulates data points from multiple frames to establish robust\nbaseline measurements for ground level and runner dimensions.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current frame's pose landmarks\n    \nCollects:\n---------\n- Ground level: Y-coordinate of lowest visible foot landmarks\n- Runner height: Distance from head landmarks to foot landmarks",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "None",
              "line_number": 189,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_finalize_calibration",
              "docstring": "Calculate final calibration values from collected sample data.\n\nUses robust statistical methods (percentiles, median) to establish ground level\nand runner height measurements that are resistant to outliers and measurement noise.\n\nSets:\n-----\n- self.ground_level_normalized: Calibrated ground Y-coordinate\n- self.avg_runner_height_normalized: Calibrated average runner height",
              "parameters": [],
              "return_type": "None",
              "line_number": 244,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_perform_stance_detection",
              "docstring": "Perform stance phase detection using calibrated parameters.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current frame's pose landmarks\n    \nReturns:\n--------\nStanceResult\n    Detection results with stance phase status, active foot, and confidence",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "StanceResult",
              "line_number": 283,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_foot_stance",
              "docstring": "Analyze stance phase for a single foot.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current frame landmarks\nside : str\n    Foot side to analyze ('left' or 'right')\nthreshold : float\n    Dynamic stance detection threshold\n    \nReturns:\n--------\nDict containing side, stance status, confidence, and foot position data",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "threshold",
                  "type": "float"
                }
              ],
              "return_type": "Dict[(str, Union[str, bool, float])]",
              "line_number": 314,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_resolve_stance_phase",
              "docstring": "Resolve overall stance phase from individual foot analyses.\n\nHandles cases of single stance, double stance (rare in running), and flight phase.\nPrioritizes the foot that is most confidently in contact with ground.\n\nParameters:\n-----------\nstance_candidates : List[Dict]\n    Results from individual foot stance analyses\n    \nReturns:\n--------\nStanceResult\n    Final stance phase determination",
              "parameters": [
                {
                  "name": "stance_candidates",
                  "type": "List[Dict[(str, Union[str, bool, float])]]"
                }
              ],
              "return_type": "StanceResult",
              "line_number": 384,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_foot_vertical_velocity",
              "docstring": "Estimate vertical velocity of foot for enhanced stance detection.\n\nThis method is currently not used in main detection but provides foundation\nfor velocity-based stance refinement.\n\nParameters:\n-----------\nside : str\n    Foot side ('left' or 'right')\ncurrent_lowest_y : float\n    Current frame's lowest Y coordinate for the foot\n    \nReturns:\n--------\nfloat\n    Estimated vertical velocity in normalized coordinates per frame\n    Positive = moving down, Negative = moving up",
              "parameters": [
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "current_lowest_y",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 457,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_calibration_status",
              "docstring": "Get current calibration status and parameters.\n\nReturns:\n--------\nCalibrationData\n    Dictionary containing calibration progress and computed values",
              "parameters": [],
              "return_type": "CalibrationData",
              "line_number": 490,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset_calibration",
              "docstring": "Reset detector to perform new calibration.\n\nUseful when switching to new video or significantly different camera angle.",
              "parameters": [],
              "return_type": "None",
              "line_number": 512,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 38,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "stance_detector_side_wrapper",
          "docstring": "Standalone wrapper function for stance phase detection.\n\nProvides functional interface to StancePhaseDetectorSide class\nfor integration with existing analysis pipelines.\n\nArgs:\n    detector: Initialized StancePhaseDetectorVelocity instance\n    landmarks: Dictionary containing pose landmarks\n    \nReturns:\n    StanceResult: Analysis results from detector",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "detector_instance",
              "type": "Optional[StancePhaseDetectorSide]"
            }
          ],
          "return_type": "StanceResult",
          "line_number": 530,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "example_usage",
          "docstring": "Demonstrate basic usage of StancePhaseDetectorSide.",
          "parameters": [],
          "return_type": null,
          "line_number": 561,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Union"
      ]
    },
    "metrics\\side\\gait_events_and_phases\\stance_phase_detector_velocity": {
      "file_path": "runnervision_utils\\metrics\\side\\gait_events_and_phases\\stance_phase_detector_velocity.py",
      "module_docstring": "Detects stance phase in running gait using velocity analysis.\n\nThis module analyzes ankle velocities to determine which foot is in stance phase\n(ground contact) during running. Stance phase is characterized by lower vertical\nvelocity and proximity to ground level.\n\nThe detector uses a sliding window approach to calculate foot velocities and\ncombines velocity with position data to identify the supporting foot.",
      "classes": [
        {
          "name": "StancePhaseDetectorVelocity",
          "docstring": "Detects stance phase in running gait using velocity analysis.\n\nThis class maintains a sliding window of ankle positions to calculate\nvertical velocities and determine which foot is currently in stance phase.\n\nStance phase detection combines:\n- Vertical velocity analysis (lower velocity indicates ground contact)\n- Relative foot height comparison\n- Confidence scoring based on velocity differences\n\nThe detector is optimized for running gait where clear velocity differences\nexist between stance and swing phases.\n\nAttributes:\n    frame_rate (float): Video frame rate in fps\n    velocity_window (int): Number of frames for velocity calculation\n    velocity_threshold (float): Velocity threshold for stance detection",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize stance phase detector.\n\nArgs:\n    frame_rate: Video frame rate in fps. Used for velocity calculations.\n    velocity_window: Number of frames to maintain for velocity analysis.\n                   Larger windows provide smoother velocity estimates\n                   but reduce temporal resolution.\n    velocity_threshold: Velocity threshold below which foot is considered\n                      in stance phase. Units are normalized coordinates\n                      per second.\n\nRaises:\n    ValueError: If parameters are outside valid ranges.",
              "parameters": [
                {
                  "name": "frame_rate",
                  "type": "float"
                },
                {
                  "name": "velocity_window",
                  "type": "int"
                },
                {
                  "name": "velocity_threshold",
                  "type": "float"
                }
              ],
              "return_type": null,
              "line_number": 48,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "update",
              "docstring": "Update detector with new landmarks and analyze stance phase.\n\nProcesses new frame data to:\n1. Calculate foot velocities over the sliding window\n2. Compare relative foot positions\n3. Determine stance foot and confidence\n4. Assess if currently in stance phase\n\nArgs:\n    landmarks: Dictionary containing pose landmarks. Must include\n              'left_ankle' and 'right_ankle' keys with (x,y,z,visibility) tuples.\n              Y-coordinates should be normalized (0.0-1.0).\n\nReturns:\n    StancePhaseResult: Dictionary containing:\n        - is_stance_phase (bool): True if in stance phase\n        - stance_foot (str): 'left', 'right', or 'unknown'\n        - left_foot_velocity (float): Left foot vertical velocity\n        - right_foot_velocity (float): Right foot vertical velocity\n        - confidence (float): Detection confidence (0.0-1.0)\n        - calculation_successful (bool): True if calculation completed",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "StancePhaseResult",
              "line_number": 86,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_velocities",
              "docstring": "Calculate average vertical velocities for both feet.\n\nComputes velocities over the available position history using\nframe-to-frame differences and temporal smoothing.\n\nReturns:\n    Tuple[float, float]: (left_velocity, right_velocity) in normalized units/second",
              "parameters": [],
              "return_type": "Tuple[(float, float)]",
              "line_number": 171,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_determine_stance_foot",
              "docstring": "Determine which foot is in stance phase and calculate confidence.\n\nCombines velocity analysis with relative foot height to score\neach foot's likelihood of being in stance phase.\n\nArgs:\n    landmarks: Current frame landmarks\n    left_velocity: Left foot vertical velocity\n    right_velocity: Right foot vertical velocity\n\nReturns:\n    Tuple[str, float]: (stance_foot, confidence_score)",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                },
                {
                  "name": "left_velocity",
                  "type": "float"
                },
                {
                  "name": "right_velocity",
                  "type": "float"
                }
              ],
              "return_type": "Tuple[(str, float)]",
              "line_number": 207,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset",
              "docstring": "Reset detector state for processing a new sequence.\n\nClears position history while preserving configuration parameters.",
              "parameters": [],
              "return_type": "None",
              "line_number": 258,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_velocity_threshold",
              "docstring": "Update velocity threshold for stance detection.\n\nArgs:\n    threshold: New velocity threshold (normalized units/second)\n    \nRaises:\n    ValueError: If threshold is negative",
              "parameters": [
                {
                  "name": "threshold",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "line_number": 267,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 27,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "stance_detector_velocity_wrapper",
          "docstring": "Standalone wrapper function for stance phase detection.\n\nProvides functional interface to StancePhaseDetectorVelocity class\nfor integration with existing analysis pipelines.\n\nArgs:\n    detector: Initialized StancePhaseDetectorVelocity instance\n    landmarks: Dictionary containing pose landmarks\n    \nReturns:\n    StancePhaseResult: Analysis results from detector",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "detector_instance",
              "type": "Optional[StancePhaseDetectorVelocity]"
            }
          ],
          "return_type": "StancePhaseResult",
          "line_number": 284,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "collections.deque",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Union",
        "typing.List",
        "math"
      ]
    },
    "metrics\\side\\gait_events_and_phases\\vertical_oscillation_analyzer": {
      "file_path": "runnervision_utils\\metrics\\side\\gait_events_and_phases\\vertical_oscillation_analyzer.py",
      "module_docstring": "Vertical oscillation analysis for running biomechanics.\n\nThis module analyzes the vertical movement of a runner's center of mass (CoM) during\nthe gait cycle. Vertical oscillation is a key efficiency metric in running performance,\nwith excessive vertical movement indicating energy waste and potential inefficiency.\n\nBiomechanical Context:\n- Optimal vertical oscillation: 6-9 cm for recreational runners\n- Elite runners typically show 4-7 cm vertical oscillation\n- Excessive oscillation (>12 cm) indicates inefficient running form\n- Related to stride mechanics, cadence, and energy expenditure\n- Connected to ground contact time and flight phase dynamics\n\nKey Metrics:\n- Peak-to-peak vertical displacement of center of mass\n- Oscillation frequency (cycles per second)\n- Efficiency ratings based on established biomechanical ranges",
      "classes": [
        {
          "name": "VerticalOscillationAnalyzer",
          "docstring": "Analyzes vertical oscillation patterns in running gait using center of mass tracking.\n\nThis analyzer maintains a sliding window of center of mass height measurements to\ncalculate vertical oscillation metrics including displacement magnitude, frequency,\nand efficiency ratings. Uses hip midpoint as CoM approximation, which provides\ngood correlation with full-body center of mass for running analysis.\n\nKey Features:\n- Real-time analysis with configurable sliding window\n- Robust frequency detection using multiple methods\n- Data quality assessment and filtering\n- Biomechanically-informed efficiency ratings\n- Outlier detection and smoothing\n\nAttributes:\n    frame_rate (float): Video frame rate for temporal calculations\n    window_size (int): Number of frames maintained for analysis\n    com_heights (deque): Sliding window of center of mass heights\n    frame_count (int): Total frames processed\n    min_data_points (int): Minimum data required for analysis\n    scale_factor (float): Conversion factor to real-world units (cm)",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize vertical oscillation analyzer.\n\nParameters:\n-----------\nframe_rate : float, default=60.0\n    Video frame rate in fps for temporal analysis.\n    Critical for accurate frequency calculations.\n    \nwindow_size : int, default=30\n    Number of frames in sliding analysis window.\n    Larger windows provide smoother analysis but less responsiveness.\n    30 frames \u2248 0.5 seconds at 60fps.\n    \nscale_factor : float, default=100.0\n    Conversion factor from normalized coordinates to centimeters.\n    Assumes normalized MediaPipe coordinates and typical body proportions.\n    May require calibration based on camera distance and setup.\n    \nsmoothing_enabled : bool, default=True\n    Whether to apply smoothing to reduce measurement noise.\n    Recommended for real-world video analysis.\n    \nRaises:\n-------\nValueError\n    If frame_rate <= 0 or window_size < 5",
              "parameters": [
                {
                  "name": "frame_rate",
                  "type": "float"
                },
                {
                  "name": "window_size",
                  "type": "int"
                },
                {
                  "name": "scale_factor",
                  "type": "float"
                },
                {
                  "name": "smoothing_enabled",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "line_number": 65,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "update",
              "docstring": "Process new frame and calculate vertical oscillation metrics.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    MediaPipe pose landmarks containing hip positions.\n    Required keys: 'left_hip', 'right_hip'\n    Format: {landmark_name: (x, y, z, visibility)}\n    \nReturns:\n--------\nOscillationResult\n    Dictionary containing:\n    - 'vertical_oscillation_cm' (float): Peak-to-peak displacement in cm\n    - 'oscillation_frequency' (float): Oscillation frequency in Hz\n    - 'efficiency_rating' (str): Biomechanical efficiency assessment\n    - 'avg_com_height' (float): Average CoM height in normalized coords\n    - 'data_quality' (str): Quality assessment of current data\n    - 'frames_analyzed' (int): Number of frames used in analysis\n    - 'calculation_successful' (bool): Whether analysis completed successfully",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "OscillationResult",
              "line_number": 136,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_extract_com_height",
              "docstring": "Extract center of mass height from hip landmarks.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Pose landmarks dictionary\n    \nReturns:\n--------\nOptional[float]\n    Center of mass Y-coordinate, or None if extraction fails",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "Optional[float]",
              "line_number": 197,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_outlier",
              "docstring": "Detect if new measurement is an outlier.\n\nUses both statistical (Z-score) and temporal (frame-to-frame change) criteria.\n\nParameters:\n-----------\nnew_height : float\n    New CoM height measurement\n    \nReturns:\n--------\nbool\n    True if measurement appears to be an outlier",
              "parameters": [
                {
                  "name": "new_height",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "line_number": 241,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_interpolate_missing_value",
              "docstring": "Interpolate CoM height when outlier detected.\n\nReturns:\n--------\nfloat\n    Interpolated CoM height value",
              "parameters": [],
              "return_type": "float",
              "line_number": 277,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_apply_smoothing",
              "docstring": "Apply temporal smoothing to reduce measurement noise.\n\nUses exponential moving average for real-time processing.\n\nParameters:\n-----------\nnew_height : float\n    Raw CoM height measurement\n    \nReturns:\n--------\nfloat\n    Smoothed CoM height",
              "parameters": [
                {
                  "name": "new_height",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 295,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_oscillation",
              "docstring": "Perform comprehensive vertical oscillation analysis.\n\nReturns:\n--------\nOscillationResult\n    Complete oscillation analysis results",
              "parameters": [],
              "return_type": "OscillationResult",
              "line_number": 318,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_frequency_advanced",
              "docstring": "Calculate oscillation frequency using multiple robust methods.\n\nCombines peak detection and spectral analysis for accuracy.\n\nParameters:\n-----------\nheights : np.ndarray\n    Array of CoM height measurements\navg_height : float\n    Average CoM height for reference\n    \nReturns:\n--------\nfloat\n    Oscillation frequency in Hz",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                },
                {
                  "name": "avg_height",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 358,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_frequency_from_peaks",
              "docstring": "Calculate frequency using peak detection.",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                },
                {
                  "name": "avg_height",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 399,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_frequency_from_zero_crossings",
              "docstring": "Calculate frequency using zero-crossing analysis.",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                },
                {
                  "name": "avg_height",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "line_number": 413,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_frequency_from_spectrum",
              "docstring": "Calculate frequency using spectral analysis.",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "line_number": 430,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_efficiency_rating",
              "docstring": "Determine biomechanical efficiency rating.\n\nBased on established research ranges for running efficiency.\n\nParameters:\n-----------\noscillation_cm : float\n    Vertical oscillation in centimeters\n    \nReturns:\n--------\nstr\n    Efficiency rating: 'excellent', 'good', 'moderate', or 'poor'",
              "parameters": [
                {
                  "name": "oscillation_cm",
                  "type": "float"
                }
              ],
              "return_type": "str",
              "line_number": 449,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_assess_data_quality",
              "docstring": "Assess overall quality of the height data.\n\nParameters:\n-----------\nheights : np.ndarray\n    Array of CoM height measurements\n    \nReturns:\n--------\nstr\n    Quality assessment: 'excellent', 'good', 'moderate', or 'poor'",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "str",
              "line_number": 471,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_smoothness_score",
              "docstring": "Calculate smoothness score based on second derivative.\n\nLower second derivative indicates smoother data.\n\nParameters:\n-----------\nheights : np.ndarray\n    Array of height measurements\n    \nReturns:\n--------\nfloat\n    Smoothness score between 0 and 1 (higher = smoother)",
              "parameters": [
                {
                  "name": "heights",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "line_number": 502,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_initialize_result",
              "docstring": "Initialize default result dictionary.",
              "parameters": [],
              "return_type": "OscillationResult",
              "line_number": 530,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset_analysis",
              "docstring": "Reset analyzer for new analysis session.",
              "parameters": [],
              "return_type": "None",
              "line_number": 546,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_analysis_summary",
              "docstring": "Get comprehensive analysis summary.\n\nReturns:\n--------\nDict containing current analysis state and parameters",
              "parameters": [],
              "return_type": "Dict[(str, Union[str, float, int])]",
              "line_number": 553,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 40,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "vertical_oscillation_wrapper",
          "docstring": "Standalone wrapper function for vertical oscillation detection.\n\nProvides functional interface to VerticalOscillationAnalyzer class\nfor integration with existing analysis pipelines.\n\nArgs:\n    detector: Initialized VerticalOscillationAnalyzer instance\n    landmarks: Dictionary containing pose landmarks\n    \nReturns:\n    OscillationResult: Analysis results from detector",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "detector_instance",
              "type": "Optional[VerticalOscillationAnalyzer]"
            }
          ],
          "return_type": "OscillationResult",
          "line_number": 578,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "example_usage",
          "docstring": "Demonstrate VerticalOscillationAnalyzer usage.",
          "parameters": [],
          "return_type": null,
          "line_number": 609,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "collections.deque",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.Tuple",
        "scipy.signal",
        "scipy.stats.zscore"
      ]
    },
    "metrics\\side\\lower_body\\foot_landing": {
      "file_path": "runnervision_utils\\metrics\\side\\lower_body\\foot_landing.py",
      "module_docstring": "Calculates horizontal foot landing position relative to the body's center of mass.\n\nThis metric evaluates whether a runner's foot lands under, ahead of, or behind their\ncenter of mass during the stance phase. Landing position affects:\n- Running efficiency and energy expenditure\n- Impact forces and injury risk\n- Propulsive forces and stride mechanics\n- Overall biomechanical efficiency\n\nKey biomechanical implications:\n- Landing under CoM: Generally more efficient, reduces braking forces\n- Landing ahead of CoM (overstriding): Increases braking forces, may reduce efficiency\n- Landing behind CoM: Uncommon but may indicate compensatory patterns",
      "classes": [],
      "functions": [
        {
          "name": "calculate_foot_landing_position",
          "docstring": "Calculate horizontal distance from foot landing to center of mass during stance phase.\n\nThis function determines where the foot lands relative to the body's center of mass,\nwhich is a key indicator of running efficiency and biomechanical quality. The analysis\nuses the hip center as a proxy for center of mass, which is biomechanically appropriate\nfor running gait analysis.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing 3D coordinates and visibility of detected pose landmarks.\n    Required keys depend on use_hip_center:\n    - If use_hip_center=True: 'left_hip', 'right_hip'\n    - Always requires ankle landmarks based on stance_foot from stance_phase\n    Each landmark is a tuple: (x, y, z, visibility).\n    \nstance_phase : StancePhaseInfo\n    Dictionary containing stance phase analysis results.\n    Required keys:\n    - 'is_stance_phase' (bool): Whether foot is in contact with ground\n    - 'stance_foot' (str): Which foot is in stance ('left' or 'right')\n    \ntolerance_cm : float, default=5.0\n    Tolerance in centimeters for considering foot landing \"under\" center of mass.\n    Smaller values are stricter in defining optimal landing position.\n    \nbody_scale_factor : float, default=100.0\n    Scaling factor to convert normalized coordinates to centimeters.\n    Assumes landmarks are normalized (0.0-1.0) and body proportions.\n    May need adjustment based on coordinate system and body size.\n    \nuse_hip_center : bool, default=True\n    Whether to use hip center as center of mass proxy.\n    If False, would require additional implementation for full CoM calculation.\n    \nReturns:\n--------\nFootLandingResult\n    Dictionary containing:\n    - \"distance_cm\" (float): Horizontal distance in cm from foot to CoM\n        Negative = foot behind CoM, Positive = foot ahead of CoM (overstriding)\n    - \"is_under_com\" (bool): True if foot lands under CoM within tolerance\n    - \"position_category\" (str): 'under', 'ahead', 'behind', or 'not_applicable'\n    - \"center_of_mass_x\" (Optional[float]): Calculated CoM x-coordinate\n    - \"foot_position_x\" (Optional[float]): Foot landing x-coordinate\n    - \"calculation_successful\" (bool): True if analysis completed successfully\n    \nNotes:\n------\n- Analysis only performed during stance phase\n- Hip center serves as reasonable CoM approximation for running analysis\n- Distance calculation assumes normalized coordinate system\n- Positive distance indicates potential overstriding",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "stance_phase",
              "type": "StancePhaseInfo"
            },
            {
              "name": "tolerance_cm",
              "type": "float"
            },
            {
              "name": "body_scale_factor",
              "type": "float"
            },
            {
              "name": "use_hip_center",
              "type": "bool"
            }
          ],
          "return_type": "FootLandingResult",
          "line_number": 30,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_center_of_mass",
          "docstring": "Calculate center of mass x-coordinate approximation.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks\nuse_hip_center : bool\n    Whether to use hip center as CoM approximation\n    \nReturns:\n--------\nOptional[float]\n    Center of mass x-coordinate, or None if calculation fails",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "use_hip_center",
              "type": "bool"
            }
          ],
          "return_type": "Optional[float]",
          "line_number": 167,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_get_stance_foot_position",
          "docstring": "Get the x-coordinate of the stance foot ankle.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks\nstance_foot : str\n    Which foot is in stance ('left' or 'right')\n    \nReturns:\n--------\nOptional[float]\n    Foot ankle x-coordinate, or None if not found",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "stance_foot",
              "type": "str"
            }
          ],
          "return_type": "Optional[float]",
          "line_number": 206,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_categorize_landing_position",
          "docstring": "Categorize foot landing position relative to center of mass.\n\nParameters:\n-----------\ndistance_cm : float\n    Horizontal distance from foot to CoM in centimeters\ntolerance_cm : float\n    Tolerance for \"under\" classification\n    \nReturns:\n--------\nstr\n    Position category: 'under', 'ahead', or 'behind'",
          "parameters": [
            {
              "name": "distance_cm",
              "type": "float"
            },
            {
              "name": "tolerance_cm",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 239,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Union"
      ]
    },
    "metrics\\side\\lower_body\\foot_strike": {
      "file_path": "runnervision_utils\\metrics\\side\\lower_body\\foot_strike.py",
      "module_docstring": "Analyzes foot strike patterns during running from side-view pose landmarks.\n\nThis module determines whether a runner exhibits heel strike, midfoot strike, \nor forefoot strike patterns. The strike pattern analysis is crucial for:\n- Understanding impact forces and injury risk\n- Optimizing running efficiency\n- Identifying biomechanical compensations\n- Guiding footwear and training recommendations\n\nFoot strike patterns have different biomechanical implications:\n- Heel strike: Most common, may increase impact forces and loading rates\n- Midfoot strike: Often provides balance between impact absorption and propulsion\n- Forefoot strike: May reduce impact forces but increases calf/Achilles tendon loading",
      "classes": [],
      "functions": [
        {
          "name": "calculate_foot_strike",
          "docstring": "Determine foot strike pattern (heel, midfoot, forefoot) from side-view pose landmarks.\n\nThis function analyzes the relative positions of the heel and toe at foot contact\nto classify the strike pattern. Multiple biomechanical indicators are used for\nrobust classification including vertical position differences, foot angles, and\nankle angles.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing 3D coordinates and visibility of detected pose landmarks.\n    Required keys: 'right_heel', 'right_foot_index', 'right_ankle'.\n    Each landmark is a tuple: (x, y, z, visibility).\n    Coordinates are typically normalized (0.0-1.0).\n    \nstance_phase : StancePhaseInfo\n    Dictionary containing stance phase analysis results.\n    Must include 'is_stance_phase' (bool) indicating if foot is in contact with ground.\n    \nvertical_threshold_heel : float, default=0.015\n    Minimum vertical difference (heel_y - toe_y) to classify as heel strike.\n    Positive values indicate heel is lower than toe in image coordinates.\n    \nvertical_threshold_forefoot : float, default=-0.01\n    Maximum vertical difference (heel_y - toe_y) to classify as forefoot strike.\n    Negative values indicate toe is lower than heel in image coordinates.\n    \nconfidence_scaling_heel : float, default=0.03\n    Scaling factor for heel strike confidence calculation.\n    Higher values result in lower confidence for same vertical difference.\n    \nconfidence_scaling_forefoot : float, default=0.02\n    Scaling factor for forefoot strike confidence calculation.\n    Higher values result in lower confidence for same vertical difference.\n    \nangle_contradiction_penalty : float, default=0.7\n    Multiplier applied to confidence when foot angle contradicts strike pattern.\n    Should be between 0.0 and 1.0.\n\nReturns:\n--------\nFootStrikeResult\n    Dictionary containing:\n    - \"strike_pattern\" (str): One of 'heel', 'midfoot', 'forefoot', or 'not_applicable'\n    - \"confidence\" (float): Confidence score (0.0-1.0) for the classification\n    - \"vertical_difference\" (float): Heel Y - Toe Y position difference\n    - \"foot_angle\" (float): Foot angle relative to horizontal (degrees)\n    - \"ankle_angle\" (float): Ankle dorsiflexion/plantarflexion angle (degrees)\n    - \"landing_stiffness\" (str): One of 'stiff', 'moderate', 'compliant', or 'not_applicable'\n    - \"calculation_successful\" (bool): True if analysis completed, False if failed\n    \nNotes:\n------\n- Analysis only performed during stance phase (foot contact with ground)\n- Coordinate system assumes higher Y values = lower position in image\n- Positive foot angle = heel lower than toe (dorsiflexion)\n- Negative foot angle = toe lower than heel (plantarflexion)\n- Ankle angle interpretation: negative = stiff landing, positive = compliant landing",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "stance_phase",
              "type": "StancePhaseInfo"
            },
            {
              "name": "vertical_threshold_heel",
              "type": "float"
            },
            {
              "name": "vertical_threshold_forefoot",
              "type": "float"
            },
            {
              "name": "confidence_scaling_heel",
              "type": "float"
            },
            {
              "name": "confidence_scaling_forefoot",
              "type": "float"
            },
            {
              "name": "angle_contradiction_penalty",
              "type": "float"
            }
          ],
          "return_type": "FootStrikeResult",
          "line_number": 31,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_foot_angle",
          "docstring": "Calculate the angle of the foot relative to horizontal.\n\nParameters:\n-----------\nheel_x, heel_y : float\n    Heel landmark coordinates\ntoe_x, toe_y : float\n    Toe (foot index) landmark coordinates\n    \nReturns:\n--------\nfloat\n    Foot angle in degrees. Positive = heel lower than toe, Negative = toe lower than heel",
          "parameters": [
            {
              "name": "heel_x",
              "type": "float"
            },
            {
              "name": "heel_y",
              "type": "float"
            },
            {
              "name": "toe_x",
              "type": "float"
            },
            {
              "name": "toe_y",
              "type": "float"
            }
          ],
          "return_type": "float",
          "line_number": 203,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_ankle_angle",
          "docstring": "Calculate ankle angle (dorsiflexion/plantarflexion).\n\nParameters:\n-----------\nankle_x, ankle_y : float\n    Ankle landmark coordinates\nheel_x, heel_y : float\n    Heel landmark coordinates\n    \nReturns:\n--------\nfloat\n    Ankle angle in degrees. Negative = more vertical shin (stiff), Positive = angled shin (compliant)",
          "parameters": [
            {
              "name": "ankle_x",
              "type": "float"
            },
            {
              "name": "ankle_y",
              "type": "float"
            },
            {
              "name": "heel_x",
              "type": "float"
            },
            {
              "name": "heel_y",
              "type": "float"
            }
          ],
          "return_type": "float",
          "line_number": 228,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_classify_strike_pattern",
          "docstring": "Classify strike pattern based on vertical difference between heel and toe.\n\nParameters:\n-----------\nvertical_difference : float\n    Heel Y - Toe Y position difference\nheel_threshold : float\n    Threshold for heel strike classification\nforefoot_threshold : float\n    Threshold for forefoot strike classification\nheel_scaling : float\n    Confidence scaling factor for heel strike\nforefoot_scaling : float\n    Confidence scaling factor for forefoot strike\n    \nReturns:\n--------\nTuple[str, float]\n    Strike pattern classification and confidence score",
          "parameters": [
            {
              "name": "vertical_difference",
              "type": "float"
            },
            {
              "name": "heel_threshold",
              "type": "float"
            },
            {
              "name": "forefoot_threshold",
              "type": "float"
            },
            {
              "name": "heel_scaling",
              "type": "float"
            },
            {
              "name": "forefoot_scaling",
              "type": "float"
            }
          ],
          "return_type": "Tuple[(str, float)]",
          "line_number": 253,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_apply_angle_validation",
          "docstring": "Apply secondary validation using foot angle to adjust confidence.\n\nParameters:\n-----------\nstrike_pattern : str\n    Primary strike pattern classification\nfoot_angle : float\n    Calculated foot angle in degrees\nconfidence : float\n    Initial confidence score\npenalty : float\n    Penalty multiplier for contradicting angles\n    \nReturns:\n--------\nfloat\n    Adjusted confidence score",
          "parameters": [
            {
              "name": "strike_pattern",
              "type": "str"
            },
            {
              "name": "foot_angle",
              "type": "float"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "penalty",
              "type": "float"
            }
          ],
          "return_type": "float",
          "line_number": 302,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_classify_landing_stiffness",
          "docstring": "Classify landing stiffness based on ankle angle at foot contact.\n\nParameters:\n-----------\nankle_angle : float\n    Ankle angle in degrees\n    \nReturns:\n--------\nstr\n    Landing stiffness classification: 'stiff', 'moderate', or 'compliant'",
          "parameters": [
            {
              "name": "ankle_angle",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 341,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "math",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any",
        "typing.Union"
      ]
    },
    "metrics\\side\\lower_body\\knee_angle": {
      "file_path": "runnervision_utils\\metrics\\side\\lower_body\\knee_angle.py",
      "module_docstring": "Calculates knee flexion/extension angles from pose landmarks.\n\nThis module analyzes knee joint angles to assess running biomechanics,\nidentify potential overstriding, and evaluate leg extension patterns\nthat may impact performance or injury risk.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_knee_angle",
          "docstring": "Calculate knee flexion/extension angle from hip-knee-ankle landmarks.\n\nComputes the interior angle at the knee joint using vector dot product.\nReturns extension angle where 180\u00b0 represents fully straight leg and\nsmaller values indicate increasing knee flexion.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks with (x, y, z, visibility) coordinates.\n    Required keys: '{side}_hip', '{side}_knee', '{side}_ankle'\n    \nside : Side\n    Leg side to analyze ('left' or 'right')\n    \nReturns:\n--------\nKneeAngleResult\n    Dictionary containing:\n    - \"knee_angle\" (Optional[float]): Knee extension angle in degrees (180\u00b0 = straight)\n    - \"knee_flexion\" (Optional[float]): Knee flexion from straight position in degrees\n    - \"leg_extension_assessment\" (Optional[str]): Qualitative assessment of leg extension\n    - \"side\" (str): Which leg was analyzed\n    - \"calculation_successful\" (bool): True if angle calculated successfully",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "side",
              "type": "Side"
            }
          ],
          "return_type": "KneeAngleResult",
          "line_number": 29,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_joint_angle",
          "docstring": "Calculate interior angle at a joint using vector dot product method.\n\nParameters:\n-----------\nproximal : Tuple[float, float]\n    Coordinates of proximal landmark (e.g., hip)\njoint : Tuple[float, float]\n    Coordinates of joint center (e.g., knee)\ndistal : Tuple[float, float]\n    Coordinates of distal landmark (e.g., ankle)\n    \nReturns:\n--------\nOptional[float]\n    Joint angle in degrees, or None if calculation fails",
          "parameters": [
            {
              "name": "proximal",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "joint",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "distal",
              "type": "Tuple[(float, float)]"
            }
          ],
          "return_type": "Optional[float]",
          "line_number": 115,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_assess_leg_extension",
          "docstring": "Provide qualitative assessment of leg extension based on knee angle.\n\nParameters:\n-----------\nknee_angle : float\n    Knee extension angle in degrees\n    \nReturns:\n--------\nstr\n    Qualitative assessment of leg extension",
          "parameters": [
            {
              "name": "knee_angle",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 175,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "calculate_bilateral_knee_angles",
          "docstring": "Calculate knee angles for both legs simultaneously.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks for both legs\n    \nReturns:\n--------\nDict[str, KneeAngleResult]\n    Dictionary with 'left' and 'right' keys containing respective knee analyses",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            }
          ],
          "return_type": "Dict[(str, KneeAngleResult)]",
          "line_number": 203,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_knee_asymmetry",
          "docstring": "Analyze asymmetry between left and right knee angles.\n\nParameters:\n-----------\nleft_result : KneeAngleResult\n    Left knee analysis result\nright_result : KneeAngleResult\n    Right knee analysis result\n    \nReturns:\n--------\nDict[str, Any]\n    Asymmetry analysis including angle difference and assessment",
          "parameters": [
            {
              "name": "left_result",
              "type": "KneeAngleResult"
            },
            {
              "name": "right_result",
              "type": "KneeAngleResult"
            }
          ],
          "return_type": "Dict[(str, Any)]",
          "line_number": 225,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "math",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any",
        "typing.Literal"
      ]
    },
    "metrics\\side\\lower_body\\stride_length": {
      "file_path": "runnervision_utils\\metrics\\side\\lower_body\\stride_length.py",
      "module_docstring": "Estimates stride length and related biomechanical metrics for running analysis.\n\nThis module calculates stride length using temporal tracking of foot positions,\noptimized for side-view analysis. It provides both instantaneous estimates and\nsmoothed temporal measurements with confidence scoring.",
      "classes": [],
      "functions": [
        {
          "name": "estimate_stride_length",
          "docstring": "Estimate stride length based on foot positions with temporal tracking,\noptimized for side-view analysis.\n\nThis function analyzes foot movement patterns to detect touchdown events\nand calculate stride metrics. It uses both instantaneous estimates from\ncurrent pose and temporal tracking for improved accuracy.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks with (x, y, z, visibility) coordinates.\n    Required keys: 'right_foot_index', 'right_ankle', 'right_knee', 'right_hip'.\n    Optional keys: 'right_shoulder', 'nose', 'right_ear', 'right_eye' for height estimation.\n    Coordinates are typically normalized (0.0-1.0).\n    \nframe_index : Optional[int], default=None\n    Current frame index for temporal tracking. If None, only instantaneous\n    estimates will be calculated.\n    \nheight_cm : Optional[float], default=None\n    Runner's height in centimeters. If provided, improves scale factor accuracy\n    and enables normalized stride length calculation.\n    \ntemporal_tracking : Optional[TemporalTrackingData], default=None\n    Previous temporal tracking data to maintain state across frames.\n    If None, new tracking data will be initialized.\n    \nfps : float, default=30.0\n    Video frame rate in frames per second, used for timing calculations.\n    \nthreshold_proportion : float, default=0.25\n    Velocity threshold proportion for touchdown detection. Lower values\n    make touchdown detection more sensitive.\n\nReturns:\n--------\nTuple[StrideAnalysisResult, Optional[TemporalTrackingData]]\n    A tuple containing:\n    - StrideAnalysisResult: Dictionary with stride analysis metrics\n    - TemporalTrackingData: Updated temporal tracking data (None if frame_index is None)\n    \nStrideAnalysisResult contains:\n    - \"instantaneous_estimate_cm\" (Optional[float]): Current stride estimate from pose\n    - \"stride_length_cm\" (Optional[float]): Smoothed stride length from temporal tracking\n    - \"normalized_stride_length\" (Optional[float]): Stride length relative to height (0.0-2.0 typical range)\n    - \"stride_frequency\" (Optional[float]): Cadence in strides per minute\n    - \"assessment\" (Optional[str]): Stride appropriateness (\"optimal\", \"too_short\", \"too_long\", \"insufficient_data\")\n    - \"confidence\" (float): Measurement confidence (0.0-1.0)\n    - \"calculation_successful\" (bool): True if basic calculations completed",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "frame_index",
              "type": "Optional[int]"
            },
            {
              "name": "height_cm",
              "type": "Optional[float]"
            },
            {
              "name": "temporal_tracking",
              "type": "Optional[TemporalTrackingData]"
            },
            {
              "name": "fps",
              "type": "float"
            },
            {
              "name": "threshold_proportion",
              "type": "float"
            }
          ],
          "return_type": "Tuple[(StrideAnalysisResult, Optional[TemporalTrackingData])]",
          "line_number": 27,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_side_view_scale_factor",
          "docstring": "Calculate scale factor for converting normalized coordinates to centimeters.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks\nheight_cm : Optional[float]\n    Known runner height in cm for accurate scaling\n    \nReturns:\n--------\nfloat\n    Scale factor for coordinate conversion",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "height_cm",
              "type": "Optional[float]"
            }
          ],
          "return_type": "float",
          "line_number": 166,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_initialize_or_update_temporal_tracking",
          "docstring": "Initialize or update temporal tracking data for stride detection.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current frame landmarks\nframe_index : int\n    Current frame number\ntemporal_tracking : Optional[TemporalTrackingData]\n    Previous tracking data\nfps : float\n    Video frame rate\nthreshold_proportion : float\n    Velocity threshold for touchdown detection\nscale_factor : float\n    Coordinate to centimeter conversion factor\n    \nReturns:\n--------\nTemporalTrackingData\n    Updated temporal tracking data",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "frame_index",
              "type": "int"
            },
            {
              "name": "temporal_tracking",
              "type": "Optional[TemporalTrackingData]"
            },
            {
              "name": "fps",
              "type": "float"
            },
            {
              "name": "threshold_proportion",
              "type": "float"
            },
            {
              "name": "scale_factor",
              "type": "float"
            }
          ],
          "return_type": "TemporalTrackingData",
          "line_number": 240,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_detect_foot_touchdown",
          "docstring": "Detect foot touchdown based on position and velocity patterns.\n\nParameters:\n-----------\ntemporal_tracking : TemporalTrackingData\n    Current tracking data\ncurrent_foot_pos : np.ndarray\n    Current foot position [x, y]\nthreshold_proportion : float\n    Velocity threshold proportion\n    \nReturns:\n--------\nbool\n    True if touchdown detected",
          "parameters": [
            {
              "name": "temporal_tracking",
              "type": "TemporalTrackingData"
            },
            {
              "name": "current_foot_pos",
              "type": "np.ndarray"
            },
            {
              "name": "threshold_proportion",
              "type": "float"
            }
          ],
          "return_type": "bool",
          "line_number": 330,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_update_stride_metrics",
          "docstring": "Update stride length and timing metrics based on recent touchdown events.\n\nParameters:\n-----------\ntemporal_tracking : TemporalTrackingData\n    Tracking data to update\nscale_factor : float\n    Coordinate to centimeter conversion factor\nfps : float\n    Video frame rate",
          "parameters": [
            {
              "name": "temporal_tracking",
              "type": "TemporalTrackingData"
            },
            {
              "name": "scale_factor",
              "type": "float"
            },
            {
              "name": "fps",
              "type": "float"
            }
          ],
          "return_type": "None",
          "line_number": 378,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_instantaneous_stride_estimate",
          "docstring": "Calculate instantaneous stride estimate from current pose.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current pose landmarks\nscale_factor : float\n    Coordinate to centimeter conversion factor\n    \nReturns:\n--------\nfloat\n    Instantaneous stride estimate in centimeters",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "scale_factor",
              "type": "float"
            }
          ],
          "return_type": "float",
          "line_number": 426,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_estimate_height_from_side_view",
          "docstring": "Estimate runner's height from side-view landmarks.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Pose landmarks\nscale_factor : float\n    Coordinate to centimeter conversion factor\n    \nReturns:\n--------\nOptional[float]\n    Estimated height in cm, or None if estimation fails",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "scale_factor",
              "type": "float"
            }
          ],
          "return_type": "Optional[float]",
          "line_number": 460,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_assess_stride_length",
          "docstring": "Assess stride length appropriateness based on normalized value.\n\nParameters:\n-----------\nnormalized_stride_length : float\n    Stride length as proportion of height\n    \nReturns:\n--------\nstr\n    Assessment: \"optimal\", \"too_short\", or \"too_long\"",
          "parameters": [
            {
              "name": "normalized_stride_length",
              "type": "float"
            }
          ],
          "return_type": "str",
          "line_number": 531,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "numpy",
        "typing.Dict",
        "typing.Tuple",
        "typing.List",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\side\\lower_body\\trunk_angle": {
      "file_path": "runnervision_utils\\metrics\\side\\lower_body\\trunk_angle.py",
      "module_docstring": "Calculates trunk forward lean angle for running biomechanics analysis.\n\nThis metric measures the forward lean of the runner's trunk relative to vertical,\nwhich is crucial for efficient running mechanics. Optimal forward lean (5-10\u00b0) \nhelps with momentum and reduces braking forces, while excessive or insufficient \nlean can lead to inefficiencies and injury risk.",
      "classes": [],
      "functions": [
        {
          "name": "calculate_trunk_angle",
          "docstring": "Calculate trunk forward lean angle relative to vertical from side view.\n\nThe trunk angle is calculated using hip and shoulder midpoints to determine\nthe trunk's deviation from vertical. Positive angles indicate forward lean,\nnegative angles indicate backward lean. Temporal smoothing is applied to\nreduce noise between frames.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing 3D coordinates and visibility of pose landmarks.\n    Required keys: 'left_hip', 'right_hip', 'left_shoulder', 'right_shoulder'\n    Optional keys: 'neck' (for improved upper trunk representation)\n    Each landmark is a tuple: (x, y, z, visibility)\n    \nsmoothing_factor : float, default=0.3\n    Temporal smoothing factor (0.0-1.0). Higher values provide more smoothing\n    but slower response to actual changes. 0.0 = no smoothing, 1.0 = maximum smoothing.\n    \nprevious_angle : Optional[float], default=None\n    Previous frame's trunk angle for temporal smoothing. If None, no smoothing applied.\n    \nestimated_speed_mps : Optional[float], default=None\n    Estimated running speed in meters per second. Used to adjust optimal range\n    recommendations based on running pace.\n\nReturns:\n--------\nTrunkAngleResult\n    Dictionary containing:\n    - \"angle_degrees\" (Optional[float]): Forward lean angle in degrees. \n        Positive = forward lean, negative = backward lean. None if calculation fails.\n    - \"is_optimal\" (Optional[bool]): True if angle is within optimal range (5-10\u00b0). \n        None if calculation fails.\n    - \"assessment\" (Optional[str]): Categorical assessment of trunk position.\n        Values: 'backward_lean', 'insufficient_forward_lean', 'optimal_forward_lean',\n        'moderate_forward_lean', 'excessive_forward_lean'. None if calculation fails.\n    - \"assessment_detail\" (Optional[str]): Detailed explanation and recommendations.\n        None if calculation fails.\n    - \"confidence\" (Optional[float]): Confidence score (0.0-1.0) based on landmark\n        visibility and measurement reliability. None if calculation fails.\n    - \"calculation_successful\" (bool): True if metrics were calculated successfully.",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "smoothing_factor",
              "type": "float"
            },
            {
              "name": "previous_angle",
              "type": "Optional[float]"
            },
            {
              "name": "estimated_speed_mps",
              "type": "Optional[float]"
            }
          ],
          "return_type": "TrunkAngleResult",
          "line_number": 23,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_trunk_confidence",
          "docstring": "Calculate confidence score for trunk angle measurement.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks with visibility scores\ncurrent_angle : float\n    Current calculated trunk angle in degrees\nprevious_angle : Optional[float]\n    Previous frame's angle for temporal consistency check\n    \nReturns:\n--------\nfloat\n    Confidence score between 0.0 and 1.0",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "current_angle",
              "type": "float"
            },
            {
              "name": "previous_angle",
              "type": "Optional[float]"
            }
          ],
          "return_type": "float",
          "line_number": 184,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_is_trunk_potentially_occluded",
          "docstring": "Check if trunk landmarks might be occluded by arms or other factors.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks\n    \nReturns:\n--------\nbool\n    True if occlusion is likely detected",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            }
          ],
          "return_type": "bool",
          "line_number": 236,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_generate_assessment_detail",
          "docstring": "Generate detailed assessment text with recommendations.\n\nParameters:\n-----------\nassessment : str\n    Categorical assessment of trunk position\nangle_degrees : float\n    Calculated trunk angle in degrees\nestimated_speed_mps : Optional[float]\n    Estimated running speed for context-specific advice\n    \nReturns:\n--------\nstr\n    Detailed assessment with recommendations",
          "parameters": [
            {
              "name": "assessment",
              "type": "str"
            },
            {
              "name": "angle_degrees",
              "type": "float"
            },
            {
              "name": "estimated_speed_mps",
              "type": "Optional[float]"
            }
          ],
          "return_type": "str",
          "line_number": 273,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "math",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any"
      ]
    },
    "metrics\\side\\upper_body\\arm_carriage": {
      "file_path": "runnervision_utils\\metrics\\side\\upper_body\\arm_carriage.py",
      "module_docstring": "Analyzes running arm carriage and swing mechanics from pose landmarks.\n\nThis module evaluates arm position, elbow angle, hand placement, and swing amplitude\nto identify biomechanical inefficiencies that may impact running performance or \nincrease injury risk. Analysis focuses on the right arm when visible from right-side view.",
      "classes": [
        {
          "name": "ArmCarriageAnalyzer",
          "docstring": "Stateful analyzer for running arm carriage mechanics with historical tracking.\n\nMaintains internal history of arm positions to enable swing amplitude analysis\nand trend detection. Designed for frame-by-frame analysis of video data.\n\nAttributes:\n-----------\nframe_rate : float\n    Video frame rate in fps\nhistory_size : int\n    Maximum number of frames to retain in history\nframe_count : int\n    Total number of frames processed",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the arm carriage analyzer with specified parameters.\n\nParameters:\n-----------\nframe_rate : float, default=30.0\n    Video frame rate in fps\nhistory_size : int, default=60\n    Number of frames to maintain for swing analysis (typically 2 seconds of data)",
              "parameters": [
                {
                  "name": "frame_rate",
                  "type": "float"
                },
                {
                  "name": "history_size",
                  "type": "int"
                }
              ],
              "return_type": null,
              "line_number": 389,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "update",
              "docstring": "Process new frame data and update arm carriage analysis.\n\nStores current frame data in history and performs comprehensive analysis\nincluding swing amplitude calculation when sufficient history is available.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks for current frame\n    \nReturns:\n--------\nArmCarriageResult\n    Comprehensive arm carriage analysis results",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "ArmCarriageResult",
              "line_number": 410,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_has_required_landmarks",
              "docstring": "Check if required landmarks are present for analysis.",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "bool",
              "line_number": 445,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_store_frame_data",
              "docstring": "Store current frame arm position data for historical analysis.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Current frame landmarks",
              "parameters": [
                {
                  "name": "landmarks",
                  "type": "LandmarksDict"
                }
              ],
              "return_type": "None",
              "line_number": 450,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_analysis_summary",
              "docstring": "Generate a comprehensive text summary of current arm carriage state.\n\nReturns:\n--------\nstr\n    Formatted summary of arm carriage analysis",
              "parameters": [],
              "return_type": "str",
              "line_number": 483,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "reset",
              "docstring": "Reset analyzer state and clear all historical data.",
              "parameters": [],
              "return_type": "None",
              "line_number": 539,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 372,
          "bases": []
        }
      ],
      "functions": [
        {
          "name": "calculate_arm_carriage",
          "docstring": "Analyzes arm carriage mechanics from pose landmarks for a single frame.\n\nEvaluates elbow angle, hand position, and upper arm positioning to assess\nrunning form efficiency. For swing amplitude analysis, historical data\nis required via the arm_history parameter.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Dictionary containing pose landmarks with (x, y, z, visibility) coordinates.\n    Required keys: 'right_shoulder', 'right_elbow', 'right_wrist'\n    Optional keys: 'right_hip' (for hand position assessment)\n    \nframe_rate : float, default=30.0\n    Video frame rate in fps (currently unused but maintained for future features)\n    \narm_history : Optional[deque], default=None\n    Historical arm position data for swing amplitude calculation.\n    If None, swing amplitude will not be calculated.\n\nReturns:\n--------\nArmCarriageResult\n    Dictionary containing:\n    - \"upper_arm_angle\" (Optional[float]): Angle of upper arm relative to vertical in degrees\n    - \"elbow_angle\" (Optional[float]): Interior elbow angle in degrees (0\u00b0=fully bent, 180\u00b0=straight)\n    - \"hand_position\" (Optional[str]): Hand position assessment ('optimal', 'too_high', 'too_low')\n    - \"arm_swing_amplitude\" (Optional[float]): Normalized swing amplitude (1.0 = optimal)\n    - \"crosses_midline\" (Optional[bool]): True if arm crosses body midline\n    - \"overall_assessment\" (str): Overall form assessment\n    - \"recommendations\" (List[str]): List of improvement recommendations\n    - \"calculation_successful\" (bool): True if analysis completed successfully",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "frame_rate",
              "type": "float"
            },
            {
              "name": "arm_history",
              "type": "Optional[deque]"
            }
          ],
          "return_type": "ArmCarriageResult",
          "line_number": 34,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_upper_arm_angle",
          "docstring": "Calculate upper arm angle relative to vertical axis.\n\nParameters:\n-----------\nshoulder : Tuple[float, float]\n    Shoulder landmark coordinates (x, y)\nelbow : Tuple[float, float]\n    Elbow landmark coordinates (x, y)\n    \nReturns:\n--------\nfloat\n    Angle in degrees where 0\u00b0 is vertical, positive values indicate rightward lean",
          "parameters": [
            {
              "name": "shoulder",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "elbow",
              "type": "Tuple[(float, float)]"
            }
          ],
          "return_type": "float",
          "line_number": 143,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_elbow_angle",
          "docstring": "Calculate interior elbow angle using vector dot product.\n\nParameters:\n-----------\nshoulder : Tuple[float, float]\n    Shoulder landmark coordinates (x, y)\nelbow : Tuple[float, float]\n    Elbow landmark coordinates (x, y)\nwrist : Tuple[float, float]\n    Wrist landmark coordinates (x, y)\n    \nReturns:\n--------\nfloat\n    Interior elbow angle in degrees (0\u00b0 = fully bent, 180\u00b0 = straight)",
          "parameters": [
            {
              "name": "shoulder",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "elbow",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "wrist",
              "type": "Tuple[(float, float)]"
            }
          ],
          "return_type": "float",
          "line_number": 165,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_analyze_hand_position",
          "docstring": "Analyze hand vertical position relative to body landmarks.\n\nParameters:\n-----------\nlandmarks : LandmarksDict\n    Full landmarks dictionary for reference points\nshoulder : Tuple[float, float]\n    Shoulder coordinates (x, y)\nwrist : Tuple[float, float]\n    Wrist coordinates (x, y)\n    \nReturns:\n--------\nstr\n    Hand position assessment: 'optimal', 'too_high', or 'too_low'",
          "parameters": [
            {
              "name": "landmarks",
              "type": "LandmarksDict"
            },
            {
              "name": "shoulder",
              "type": "Tuple[(float, float)]"
            },
            {
              "name": "wrist",
              "type": "Tuple[(float, float)]"
            }
          ],
          "return_type": "str",
          "line_number": 211,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_calculate_swing_amplitude",
          "docstring": "Calculate arm swing amplitude from historical wrist angle data.\n\nUses percentile-based analysis to determine swing range while filtering outliers.\n\nParameters:\n-----------\narm_history : deque\n    Historical arm position data containing wrist angles\n    \nReturns:\n--------\nOptional[float]\n    Normalized swing amplitude where 1.0 represents optimal swing,\n    or None if insufficient data",
          "parameters": [
            {
              "name": "arm_history",
              "type": "deque"
            }
          ],
          "return_type": "Optional[float]",
          "line_number": 253,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_generate_assessment",
          "docstring": "Generate overall assessment and recommendations based on arm carriage metrics.\n\nParameters:\n-----------\nupper_arm_angle : float\n    Upper arm angle relative to vertical\nelbow_angle : float\n    Interior elbow angle in degrees\nhand_position : str\n    Hand position assessment\nswing_amplitude : Optional[float]\n    Normalized swing amplitude\ncrosses_midline : bool\n    Whether arm crosses body midline\n    \nReturns:\n--------\nTuple[str, List[str]]\n    Overall assessment string and list of recommendations",
          "parameters": [
            {
              "name": "upper_arm_angle",
              "type": "float"
            },
            {
              "name": "elbow_angle",
              "type": "float"
            },
            {
              "name": "hand_position",
              "type": "str"
            },
            {
              "name": "swing_amplitude",
              "type": "Optional[float]"
            },
            {
              "name": "crosses_midline",
              "type": "bool"
            }
          ],
          "return_type": "Tuple[(str, List[str])]",
          "line_number": 298,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "logging",
        "math",
        "collections.deque",
        "typing.Dict",
        "typing.Tuple",
        "typing.Optional",
        "typing.Any",
        "typing.List",
        "numpy"
      ]
    },
    "reports\\report_generators\\base_report_generator": {
      "file_path": "runnervision_utils\\reports\\report_generators\\base_report_generator.py",
      "module_docstring": null,
      "classes": [
        {
          "name": "BaseReportGenerator",
          "docstring": null,
          "methods": [
            {
              "name": "__init__",
              "docstring": null,
              "parameters": [
                {
                  "name": "metrics_df"
                },
                {
                  "name": "session_id"
                },
                {
                  "name": "reports_dir"
                },
                {
                  "name": "metadata"
                },
                {
                  "name": "report_file_path"
                }
              ],
              "return_type": null,
              "line_number": 10,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_add_html_head",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "report_title"
                }
              ],
              "return_type": null,
              "line_number": 36,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_add_metric_box",
              "docstring": "Generates the HTML for a single metric box.",
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "title"
                },
                {
                  "name": "value_str"
                },
                {
                  "name": "unit"
                },
                {
                  "name": "std_dev_str"
                },
                {
                  "name": "rating_text"
                },
                {
                  "name": "rating_key"
                },
                {
                  "name": "progress_percent"
                },
                {
                  "name": "sub_text"
                }
              ],
              "return_type": null,
              "line_number": 94,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_series_stats",
              "docstring": null,
              "parameters": [
                {
                  "name": "df"
                },
                {
                  "name": "col_name"
                },
                {
                  "name": "drop_na_val"
                }
              ],
              "return_type": null,
              "line_number": 124,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_session_info_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 149,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_main_report_structure",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "report_title_suffix"
                }
              ],
              "return_type": null,
              "line_number": 166,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "generate_html_file",
              "docstring": "Generates the HTML report and saves it to a file.",
              "parameters": [
                {
                  "name": "output_filename_base"
                }
              ],
              "return_type": null,
              "line_number": 183,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "view_name",
              "docstring": null,
              "parameters": [],
              "return_type": null,
              "line_number": 203,
              "is_async": false,
              "decorators": [
                "property"
              ]
            },
            {
              "name": "_generate_metrics_summary_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 206,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_specialized_sections",
              "docstring": "Hook for view-specific sections beyond basic summary and plots.",
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 209,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_plots_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 213,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_recommendations_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 216,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_overall_assessment_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 219,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 9,
          "bases": []
        }
      ],
      "functions": [],
      "imports": [
        "os",
        "pandas",
        "numpy",
        "matplotlib.pyplot",
        "utils.language_model_utils.LanguageModel"
      ]
    },
    "reports\\report_generators\\rear_report_details\\rear_report_generator": {
      "file_path": "runnervision_utils\\reports\\report_generators\\rear_report_details\\rear_report_generator.py",
      "module_docstring": null,
      "classes": [
        {
          "name": "RearViewReportGenerator",
          "docstring": null,
          "methods": [
            {
              "name": "view_name",
              "docstring": null,
              "parameters": [],
              "return_type": null,
              "line_number": 14,
              "is_async": false,
              "decorators": [
                "property"
              ]
            },
            {
              "name": "_generate_metrics_summary_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 17,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_specialized_sections",
              "docstring": "No specialized sections for rear view in this version.",
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 86,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_recommendations_section",
              "docstring": "Generates recommendations using the Language Model.",
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 90,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_overall_assessment_section",
              "docstring": "Overall assessment can be integrated or removed as needed.",
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 116,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_plots_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 121,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_rear_metric_plots",
              "docstring": "Create and save plots of running metrics.",
              "parameters": [],
              "return_type": null,
              "line_number": 155,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 12,
          "bases": [
            "BaseReportGenerator"
          ]
        }
      ],
      "functions": [
        {
          "name": "add_summary_metric",
          "docstring": null,
          "parameters": [
            {
              "name": "col_name"
            },
            {
              "name": "title"
            },
            {
              "name": "unit"
            },
            {
              "name": "val_format"
            },
            {
              "name": "is_categorical"
            }
          ],
          "return_type": null,
          "line_number": 48,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "os",
        "pandas",
        "numpy",
        "matplotlib.pyplot",
        "runnervision_utils.reports.report_generators.base_report_generator.BaseReportGenerator",
        "runnervision_utils.reports.rating_utils",
        "runnervision_utils.reports.text_generation",
        "matplotlib.patches.Patch"
      ]
    },
    "reports\\report_generators\\side_report_details\\side_report_generator": {
      "file_path": "runnervision_utils\\reports\\report_generators\\side_report_details\\side_report_generator.py",
      "module_docstring": null,
      "classes": [
        {
          "name": "SideViewReportGenerator",
          "docstring": null,
          "methods": [
            {
              "name": "view_name",
              "docstring": null,
              "parameters": [],
              "return_type": null,
              "line_number": 14,
              "is_async": false,
              "decorators": [
                "property"
              ]
            },
            {
              "name": "_generate_metrics_summary_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 19,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_specialized_sections",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 64,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_bilateral_comparison_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 67,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_plots_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 102,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_side_metric_plots",
              "docstring": null,
              "parameters": [],
              "return_type": null,
              "line_number": 122,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_recommendations_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                }
              ],
              "return_type": null,
              "line_number": 170,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_overall_assessment_section",
              "docstring": null,
              "parameters": [
                {
                  "name": "html_content"
                },
                {
                  "name": "summary_data"
                }
              ],
              "return_type": null,
              "line_number": 190,
              "is_async": false,
              "decorators": []
            }
          ],
          "line_number": 12,
          "bases": [
            "BaseReportGenerator"
          ]
        }
      ],
      "functions": [
        {
          "name": "add_summary_metric",
          "docstring": null,
          "parameters": [
            {
              "name": "col_name"
            },
            {
              "name": "title"
            },
            {
              "name": "unit"
            },
            {
              "name": "val_format"
            },
            {
              "name": "is_categorical"
            }
          ],
          "return_type": null,
          "line_number": 32,
          "is_async": false,
          "decorators": []
        }
      ],
      "imports": [
        "os",
        "pandas",
        "numpy",
        "matplotlib.pyplot",
        "runnervision_utils.reports.report_generators.base_report_generator.BaseReportGenerator",
        "runnervision_utils.reports.rating_utils",
        "runnervision_utils.reports.text_generation"
      ]
    }
  },
  "summary": {
    "total_blueprints": 4,
    "total_routes": 25,
    "total_services": 9,
    "total_biomechanic_modules": 24,
    "methods_distribution": {
      "GET": 19,
      "POST": 7
    },
    "blueprints_list": [
      "coach_g",
      "runner_vision",
      "running_hub",
      "run_strong"
    ],
    "services_list": [
      "activity_service",
      "base_service",
      "coach_g_service",
      "motivation_service",
      "query_service",
      "runnervision_service",
      "runstrong_service",
      "statistics_service",
      "trophy_service"
    ],
    "biomechanic_modules_list": [
      "reports\\rating_utils",
      "reports\\text_generation",
      "metrics\\rear\\gait_events_and_phases\\stance_phase_detector_rear",
      "metrics\\rear\\gait_events_and_phases\\step_width",
      "metrics\\rear\\gait_events_and_phases\\stride_symmetry",
      "metrics\\rear\\lower_body\\ankle_inversion",
      "metrics\\rear\\lower_body\\foot_crossover",
      "metrics\\rear\\lower_body\\hip_drop",
      "metrics\\rear\\lower_body\\knee_alignment",
      "metrics\\rear\\lower_body\\pelvic_tilt",
      "metrics\\rear\\upper_body\\arm_swing_mechanics",
      "metrics\\side\\gait_events_and_phases\\ground_contact_time",
      "metrics\\side\\gait_events_and_phases\\stance_phase_detector_side",
      "metrics\\side\\gait_events_and_phases\\stance_phase_detector_velocity",
      "metrics\\side\\gait_events_and_phases\\vertical_oscillation_analyzer",
      "metrics\\side\\lower_body\\foot_landing",
      "metrics\\side\\lower_body\\foot_strike",
      "metrics\\side\\lower_body\\knee_angle",
      "metrics\\side\\lower_body\\stride_length",
      "metrics\\side\\lower_body\\trunk_angle",
      "metrics\\side\\upper_body\\arm_carriage",
      "reports\\report_generators\\base_report_generator",
      "reports\\report_generators\\rear_report_details\\rear_report_generator",
      "reports\\report_generators\\side_report_details\\side_report_generator"
    ]
  }
}